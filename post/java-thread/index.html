<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gridea</title>
<meta name="description" content="温故而知新" />
<link rel="shortcut icon" href="https://sdivens.github.io/favicon.ico?v=1584774336305">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://sdivens.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://sdivens.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://sdivens.github.io/images/avatar.png?v=1584774336305" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Gridea</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">什么是线程</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B">什么是多线程</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88-%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B">为什么 用多线程</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">多线程如何使用</a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BFthread%E7%B1%BB">继承Thread类</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3">实现Runnable接口</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%B0%83%E7%94%A8start%E6%96%B9%E6%B3%95">为什么调用start()方法</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://sdivens.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">java 多线程之线程介绍</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-18 / 10 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://sdivens.github.io/post-images/java-thread.jpg" alt="">
        
        <div class="post-content yue">
          <p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
<!-- more -->
<h1 id="什么是线程">什么是线程</h1>
<p><strong>线程是一种计算机资源,负责处理或执行某件事情</strong>,比如说扫地,如果是你来扫地,那么你就是扫地的线程,如果是扫地机器人来扫地,那么扫地机器人就是扫地的线程,如果你扫完了地,又去洗菜了,那么你就变成了洗菜的线程,扫地的线程就结束了,<strong>所以线程是某件事情的执行者,这种执行者也是一种资源</strong>,因为你只有一个人,不能又扫地又洗菜,只能先做一件事,在做另外一件事</p>
<h1 id="什么是多线程">什么是多线程</h1>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">上面</a>提到线程是一种资源,比如一个扫地机器人,那么多线程指的就是多个资源,比如如果你有3个扫地机器人,那么可以一个扫卧室,一个扫大厅,还有一个扫厨房,可以同时进行,加快效率</p>
<h1 id="为什么-用多线程">为什么 用多线程</h1>
<p>在解释了什么是线程与多线程之后,我们需要了解一个问题,多线程是用来干什么的?为什么要用多线程?</p>
<p><strong>多线程是用来解决效率问题</strong>,比如上边的例子,假设家里有3个房间(卧室,大厅,厨房),假设每个房间打扫需要10分钟,如果只有一个扫地机器人的话,一共需要30分钟可以把家里全部打扫完毕,但是如果有3个机器人,那么可以每个机器人负责打扫一个房间,3个房间可以同时进行打扫,那么打扫完成3个房间一个需要10分钟就够了,所以多线程可以解决效率问题</p>
<h1 id="多线程如何使用">多线程如何使用</h1>
<p>了解了为什么要使用多线程之后,在来看如何写一个多线程呢?</p>
<p>首先是创建线程,如何创建一个线程呢?创建线程有两种方法</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="继承thread类">继承Thread类</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是继承Thread类,然后重写父类的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new MyThread().start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p><code>new MyThread().start();</code>这个代码就是先new一个实例,在调用实例的start()方法就可以调用这个线程了,那么有两个问题</p>
<ol>
<li>start()方法是干什么的?为什么要调用start()方法而不是调用run()方法?</li>
<li>这个程序的运行结果是什么?</li>
</ol>
<p>我们之后在解答这两个问题,现在我们了解了如何通过继承Thread来创建和使用一个线程,那么我们再看如何通过实现Runnable接口来创建和使用线程</p>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {
    
    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是实现Runnable接口,然后实现接口中的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?和继承Thread实现的类一样吗?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p>我们可以看到是通过<code>new Thread(new MyRunnableThread()).start()</code>来启动一个线程的,这个和Thread的方式有点不同,对比一下,Thread是通过<code>new MyThread().start();</code>来启动一个线程的,而这个呢是先new MyRunnableThread这个对象,然后在new Thread,把MyRunnableThread的对象实例传入到Thread的构造函数中,在和之前一样通过start方法来启动一个线程,这里调用的start()方法和之前的那个一样,我们再来解答之前提出的两个问题</p>
<h2 id="为什么调用start方法">为什么调用start()方法</h2>
<p>要解释这个原因,要先知道线程的6个状态,哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(就绪/可运行)</li>
<li>BLOCK(阻塞)</li>
<li>WATTING(等待运行)</li>
<li>TIME WAITING(有时间限制的等待运行)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>这6种状态我们以后再讲,现在先来说说NEW(创建)和RUNNABLE(就绪/可运行)这两个状态</p>
<p>NEW(创建)是在线程创建之后初始的状态,每一个线程刚创建的时候就是这个状态,比如说<code>new MyThread()</code>和<code>new Thread(new MyRunnableThread())</code>就处在这个状态,那么什么是RUNNABLE(就绪/可运行)状态呢?</p>
<p>RUNNABLE(就绪/可运行)是一个状态,标志着这个线程是可以运行的,等待CPU来启动它,是在线程在创建完成后调用start()方法,状态会从NEW转为RUNNABLE,当然其他状态也可以转为RUNNABLE,这个我们也以后讲到其他状态的时候在讲</p>
<p>我们说start()是修改了线程的状态,让线程进入可运行状态,等待CPU启动它,而run方法是一个普通方法,由调用者自己来执行这个方法,什么意思呢?看下面↓的例子</p>
<p>如果你现在要打扫卧室和大厅两个房间,你可以自己一个人全部打扫完,如果每一个房间需要10分钟,一个需要20分钟,我们知道只要有一个扫地机器人和你有一起打扫,那么只要10分钟就打扫完了,这个我们在[上面](#为什么 用多线程)已经说过了,但是如果只是单单给你一个机器人,就像<code>new Thread(new MyRunnableThread())</code>这样创建了一个线程,但是这个机器人(线程)还是无法使用的,它现在只是有个NEW的状态,必须等到这个机器人充满电了,变成了RUNNABLE(可运行)状态,这个时候这个机器人才可以正常扫地</p>
<p>在这个例子上,我们知道,如果只是给你一个线程,是无法和你一起执行的,你要扫大厅,还是要你自己去扫,所以你必须先扫卧室在扫大厅,当然你可以反过来,看你什么时候调用,此时打扫完成2个房间需要20分钟,这个就是调用run方法的效果,但是,如果你调用的是start()方法,那就好比你拿到一个扫地机器人后,先给他充电,充满电之后,你可以和它一起打扫2个房间,此时打扫房间只需要花费10分钟,因为你们是同时打扫的,你打扫卧室,它打扫大厅,这个就是start()方法和run()方法的区别,同时也是为什么我们要调用start()方法而不是调用run()方法</p>
<p>我们可以通过以下代码来验证一下</p>
<p>我们先看第一个,如果是调用run()方法的情况</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).run();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>此时的运行结果如下:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162542899.png" alt="image-20200318162542899" loading="lazy"></figure>
<p>我们发现,打扫卧室的是main线程,打扫大厅的实际也是main线程,说明打扫打扫着两个房间是同一个线程,而且打扫每个房间需要1秒,打扫2个房间一个花了2秒</p>
<p>那么如果将run()改成start()方法呢?会需要几秒打扫2个房间呢?我们看改完之后的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>我们将run()改成start()方法之后,我们来看一下运行的结果:</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162845172.png" alt="image-20200318162845172" loading="lazy"></figure>
<p>我们可以看到第一,打扫大厅和打扫卧室的不是同一个线程,说明确实有两个线程(主人+扫地机器人)在打扫房间,另外打扫完成一个花了1秒钟,说明这两个房间确实是同时在打扫的</p>
<p>那么现在,你确实知道为什么要调用start()而不用run()方法了吗?</p>
<p>还有上面的第二个问题,这个*程序的运行结果是什么?*这个问题就是上面的运行结果,你了解了吗?</p>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://sdivens.github.io/tag/F6g2TY-sw/">
            <span class="flex-auto">java</span>
          </a>
        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://sdivens.github.io/tag/RQB_tk3ym/">
            <span class="flex-auto">多线程</span>
          </a>
        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://sdivens.github.io/post/threadStatus/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  线程的状态
                </h3>
              </a>
            </div>
          

          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'ada3a2adfeb6257b7b99',
    clientSecret: 'd0ab2be6b4f65d5a43127faf0fdf94ac250532a1',
    repo: 'sdivens.github.io',
    owner: 'sdivens',
    admin: ['sdivens'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://sdivens.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
