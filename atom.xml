<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sdivens.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-19T06:17:46.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sdivens.github.io"/>
    <link rel="self" href="https://sdivens.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://sdivens.github.io/images/avatar.png</logo>
    <icon>https://sdivens.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[线程中止的几种方式]]></title>
        <id>https://sdivens.github.io/post/thread-interrupt/</id>
        <link href="https://sdivens.github.io/post/thread-interrupt/">
        </link>
        <updated>2020-03-19T06:13:18.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<p>我们已经知道了线程的<a href="https://sdivens.github.io/post/threadStatus">6种状态</a>,现在我们在说一下终止线程的几种方式</p>
<ol>
<li>stop(<strong>不建议</strong>)</li>
<li>interrupt</li>
<li>标志位</li>
</ol>
<p>我们先说stop</p>
<h1 id="stop">stop</h1>
<p>stop是终止线程的一种方法</p>
<p>调用stop会终止一个线程并且清除监视器锁的信息,但是可能<strong>导致线程安全问题</strong>,JDK不建议使用,为什么不建议使用?因为它破坏了synchronized的原子性,我们来验证一下</p>
<p>我们先定义一个线程</p>
<pre><code class="language-java">public class StopThread extends Thread {
    private int i = 0, j = 0;

    @Override
    public void run() {
        synchronized (this) {
            // 增加同步锁，确保线程安全
            ++i;
            try {
                // 休眠10秒,模拟耗时操作
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            ++j;
        }
    }

    /** * 打印i和j */
    public void print() {
        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
    }
}
</code></pre>
<p>在这个线程中,我们定义了一个同步代码块,主要是进行<code>++i</code>和<code>++j</code>操作,而且这两个操作是原子性的,要么都成功,要么都失败</p>
<p>现在我们用另一个线程来启动这个线程</p>
<pre><code class="language-java">public class ThreadStopDemo {
    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        thread.start();
        // 休眠1秒，确保i变量自增成功
        Thread.sleep(1000);
        // 暂停线程
          thread.stop(); // 错误的终止
        while (thread.isAlive()) {
            // 确保线程已经终止
        } // 输出结果
        thread.print();
    }
}
</code></pre>
<p>这个运行的过程我们可以看一下这个示例图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/image-20200319134708307.png" alt="image-20200319134708307" loading="lazy"></figure>
<p>ThreadStopDemo先启动一个StopThread线程,然后自己休眠1秒,这个时候StopThread开始执行<code>i++</code>,执行完<code>i++</code>之后,线程休眠10秒,一秒钟之后,StopThread主线程重新启动,调用<code>thread.stop()</code>停止thread线程,然后等待thread线程退出,StopThread线程收到停止线程的指令之后,清除监视器锁信息,退出线程,之后的<code>++j</code>不会得到执行.主线程通过循环判断<code>thread.isAlive()</code>知道Thread子线程退出,然后主线程退出</p>
<p>这个过程中有个什么问题呢?我们要知道synchronized可以保证线程的安全,保证这个代码块的原子性,所以这个<code>i++</code>和这个<code>j++</code>应该要保证同时执行,要么都成功,要么都失败.所以预期的结果要么<code>i=j=0</code>或者<code>i=j=</code>1,但是在上述的整个过程中,线程终止破坏了这个原子性,因为<code>++i</code>执行了,但是<code>++j</code>却没有得到执行,所以最后运行的结果是<code>i = 1 j = 0</code>,所以我们说这种方式是破坏了synchronized的原子性</p>
<p>那么我们在看第二种中断线程的方法</p>
<h1 id="interrupt">interrupt</h1>
<p>这是正确的线程中止,我们看interrupt以下的几个特点</p>
<ol>
<li>如果目标线程在调用Object类的wait(),wait(long),wait(long,int),join(),join(long,int)或sleep(long,int)方法时被阻塞,那么interrupt方法会生效,目标线程的中断状态将会被清除,同时目标以上方法抛出InterruptedException异常</li>
<li>如果目标线程是被I/O或NIO中的Channel所阻塞,同样,I/O操作会被中断并且返回一个特殊的异常值,达到中止线程的目的</li>
<li>如果以上条件都不满足,则会设置目标线程的中断状态</li>
</ol>
<p>上面那个例子,如果将<code>thread.stop()</code>改成<code>thread.interrupt()</code>,那么会捕获一个InterruptedException异常,然后会输出正确值<code>i = j = 1</code>,我们看一下改完之后的运行结果:</p>
<pre><code>java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.zdw.demo.threadTest.StopThread.run(StopThread.java:13)
i=1 j=1
</code></pre>
<p>我们在看第三种中止线程的方法</p>
<h1 id="标志位">标志位</h1>
<p>我们看代码</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}
</code></pre>
<p>我们在代码中有一个类成员变量<code>public volatile static boolean flag = true</code>,然后我们在线程中了判断这个值是否为true,如果是true,俺么继续运行我们的逻辑,如果不是true,就不会进入到while循环中,线程就会结束,从而达到了中止线程的目的,那么什么时候将这个flag设为false呢,上述例子中我们是在主线程中将flag设为false,从而可以在我们需要的时候中止目标线程的执行</p>
<blockquote>
<p>注意<code>public volatile static boolean flag = true</code>中的<code>volatile</code>关键字,他保证了线程之间共享变量的可见性,以后会说到这个关键字,如果没有这个关键字,子线程是不会停止的.可以自己尝试试一下,去掉这个关键字后的运行结果</p>
</blockquote>
<p>以上就是今天说的中止线程的几种方式</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文章目录]]></title>
        <id>https://sdivens.github.io/post/toc/</id>
        <link href="https://sdivens.github.io/post/toc/">
        </link>
        <updated>2020-03-19T03:31:00.000Z</updated>
        <summary type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
<!-- more -->
<h1 id="首页"><a href="https://sdivens.github.io/">首页</a></h1>
<h1 id="多线程并发编程">多线程并发编程</h1>
<h2 id="线程介绍"><a href="https://sdivens.github.io/post/java-thread/">线程介绍</a></h2>
<h2 id="线程的状态"><a href="https://sdivens.github.io/post/threadStatus">线程的状态</a></h2>
<h2 id="线程中止的几种方式"><a href="https://sdivens.github.io/post/thread-interrupt">线程中止的几种方式</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态]]></title>
        <id>https://sdivens.github.io/post/threadStatus/</id>
        <link href="https://sdivens.github.io/post/threadStatus/">
        </link>
        <updated>2020-03-19T03:21:56.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<h1 id="线程的状态有哪些">线程的状态有哪些</h1>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>中我们提到了线程有6个状态,是哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(可运行/就绪)</li>
<li>BLOCK(阻塞)</li>
<li>WAITING(等待)</li>
<li>TIME WAITING(等待一定的时间)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>那么今天我们来具体介绍一下这6个状态以及状态之间的关系和转换</p>
<h2 id="new">NEW</h2>
<p>首先是线程的创建,<a href="https://sdivens.github.io/post/java-thread/">之前</a>我们已经说过线程是怎么创建的,线程创建之后的状态就是NEW的状态,这个是线程的初始状态</p>
<h2 id="runnable">RUNNABLE</h2>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>我们也说过RUNNABLE是线程创建之后调用线程的start()方法,然后就会进入Runnable状态,这个状态不是线程的运行状态,而是告诉cup当前状态是可运行的,等待CPU有时间来启动这个线程执行线程方法</p>
<h2 id="block">BLOCK</h2>
<p>block是阻塞状态,这个是线程阻塞等待监视器锁的一个状态,一般是处于synchronized或方法中被阻塞</p>
<h2 id="waiting">WAITING</h2>
<p>线程的等待状态,一下是不带超时时间的线程等待方式</p>
<pre><code>1. Object.wait
2. Thread.join
3. LockSupport.park
</code></pre>
<h2 id="time-waiting">TIME WAITING</h2>
<p>这个也是线程的等待状态,但是是带超时时间的,等待一段时间后自动唤醒,有以下一些方法</p>
<ol>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUtil</li>
</ol>
<h2 id="terminated">TERMINATED</h2>
<p>线程的终结状态,线程结束后的状态(包括线程正常结束和线程出现异常退出)</p>
<hr>
<p>介绍了各个线程之后我们说一些它的转换关系,可以看下边的图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/image-20200319111241472.png" alt="image-20200319111241472" loading="lazy"></figure>
<p>在这个图中可以清晰的看到各个线程之间的转换关系</p>
<p>然后在通过代码示例来验证一下</p>
<pre><code class="language-java">public class ThreadStatusDemo {
    public static Thread thread1;
    public static ThreadStatusDemo obj;

    public static void main(String[] args) throws Exception {
        // 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
        System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread1 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
        thread1.start();
        Thread.sleep(2000L); // 等待thread1执行结束，再看状态
        System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
        // thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

        System.out.println();
        System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {// 将线程2移动到等待状态，1500后自动唤醒
                    Thread.sleep(1500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread2 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        thread2.start();
        System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(200L); // 等待200毫秒，再看状态
        System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
        System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

        System.out.println();
        System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (ThreadStatusDemo.class) {
                    System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
                    System.out.println(&quot;thread3 执行了&quot;);
                }
            }
        });
        synchronized (ThreadStatusDemo.class) {
            System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            thread3.start();
            System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            Thread.sleep(200L); // 等待200毫秒，再看状态
            System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
        }
        Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
        System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread3.getState().toString());

    }

}
</code></pre>
<p>执行结果如下:</p>
<pre><code>#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################
没调用start方法，thread1当前状态：NEW
thread1当前状态：RUNNABLE
thread1 执行了
等待两秒，再看thread1当前状态：TERMINATED

############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################
没调用start方法，thread2当前状态：NEW
调用start方法，thread2当前状态：RUNNABLE
等待200毫秒，再看thread2当前状态：TIMED_WAITING
thread2当前状态：RUNNABLE
thread2 执行了
等待3秒，再看thread2当前状态：TERMINATED

############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################
没调用start方法，thread3当前状态：NEW
调用start方法，thread3当前状态：RUNNABLE
等待200毫秒，再看thread3当前状态：BLOCKED
thread3当前状态：RUNNABLE
thread3 执行了
等待3秒，让thread3抢到锁，再看thread3当前状态：TERMINATED
</code></pre>
<p>好了,对于线程的状态都了解了吗?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 多线程之线程介绍]]></title>
        <id>https://sdivens.github.io/post/java-thread/</id>
        <link href="https://sdivens.github.io/post/java-thread/">
        </link>
        <updated>2020-03-18T08:33:08.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
<!-- more -->
<h1 id="什么是线程">什么是线程</h1>
<p><strong>线程是一种计算机资源,负责处理或执行某件事情</strong>,比如说扫地,如果是你来扫地,那么你就是扫地的线程,如果是扫地机器人来扫地,那么扫地机器人就是扫地的线程,如果你扫完了地,又去洗菜了,那么你就变成了洗菜的线程,扫地的线程就结束了,<strong>所以线程是某件事情的执行者,这种执行者也是一种资源</strong>,因为你只有一个人,不能又扫地又洗菜,只能先做一件事,在做另外一件事</p>
<h1 id="什么是多线程">什么是多线程</h1>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">上面</a>提到线程是一种资源,比如一个扫地机器人,那么多线程指的就是多个资源,比如如果你有3个扫地机器人,那么可以一个扫卧室,一个扫大厅,还有一个扫厨房,可以同时进行,加快效率</p>
<h1 id="为什么-用多线程">为什么 用多线程</h1>
<p>在解释了什么是线程与多线程之后,我们需要了解一个问题,多线程是用来干什么的?为什么要用多线程?</p>
<p><strong>多线程是用来解决效率问题</strong>,比如上边的例子,假设家里有3个房间(卧室,大厅,厨房),假设每个房间打扫需要10分钟,如果只有一个扫地机器人的话,一共需要30分钟可以把家里全部打扫完毕,但是如果有3个机器人,那么可以每个机器人负责打扫一个房间,3个房间可以同时进行打扫,那么打扫完成3个房间一个需要10分钟就够了,所以多线程可以解决效率问题</p>
<h1 id="多线程如何使用">多线程如何使用</h1>
<p>了解了为什么要使用多线程之后,在来看如何写一个多线程呢?</p>
<p>首先是创建线程,如何创建一个线程呢?创建线程有两种方法</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="继承thread类">继承Thread类</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是继承Thread类,然后重写父类的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new MyThread().start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p><code>new MyThread().start();</code>这个代码就是先new一个实例,在调用实例的start()方法就可以调用这个线程了,那么有两个问题</p>
<ol>
<li>start()方法是干什么的?为什么要调用start()方法而不是调用run()方法?</li>
<li>这个程序的运行结果是什么?</li>
</ol>
<p>我们之后在解答这两个问题,现在我们了解了如何通过继承Thread来创建和使用一个线程,那么我们再看如何通过实现Runnable接口来创建和使用线程</p>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {
    
    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是实现Runnable接口,然后实现接口中的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?和继承Thread实现的类一样吗?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p>我们可以看到是通过<code>new Thread(new MyRunnableThread()).start()</code>来启动一个线程的,这个和Thread的方式有点不同,对比一下,Thread是通过<code>new MyThread().start();</code>来启动一个线程的,而这个呢是先new MyRunnableThread这个对象,然后在new Thread,把MyRunnableThread的对象实例传入到Thread的构造函数中,在和之前一样通过start方法来启动一个线程,这里调用的start()方法和之前的那个一样,我们再来解答之前提出的两个问题</p>
<h2 id="为什么调用start方法">为什么调用start()方法</h2>
<p>要解释这个原因,要先知道线程的6个状态,哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(就绪/可运行)</li>
<li>BLOCK(阻塞)</li>
<li>WATTING(等待运行)</li>
<li>TIME WAITING(有时间限制的等待运行)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>这6种状态我们以后再讲,现在先来说说NEW(创建)和RUNNABLE(就绪/可运行)这两个状态</p>
<p>NEW(创建)是在线程创建之后初始的状态,每一个线程刚创建的时候就是这个状态,比如说<code>new MyThread()</code>和<code>new Thread(new MyRunnableThread())</code>就处在这个状态,那么什么是RUNNABLE(就绪/可运行)状态呢?</p>
<p>RUNNABLE(就绪/可运行)是一个状态,标志着这个线程是可以运行的,等待CPU来启动它,是在线程在创建完成后调用start()方法,状态会从NEW转为RUNNABLE,当然其他状态也可以转为RUNNABLE,这个我们也以后讲到其他状态的时候在讲</p>
<p>我们说start()是修改了线程的状态,让线程进入可运行状态,等待CPU启动它,而run方法是一个普通方法,由调用者自己来执行这个方法,什么意思呢?看下面↓的例子</p>
<p>如果你现在要打扫卧室和大厅两个房间,你可以自己一个人全部打扫完,如果每一个房间需要10分钟,一个需要20分钟,我们知道只要有一个扫地机器人和你有一起打扫,那么只要10分钟就打扫完了,这个我们在[上面](#为什么 用多线程)已经说过了,但是如果只是单单给你一个机器人,就像<code>new Thread(new MyRunnableThread())</code>这样创建了一个线程,但是这个机器人(线程)还是无法使用的,它现在只是有个NEW的状态,必须等到这个机器人充满电了,变成了RUNNABLE(可运行)状态,这个时候这个机器人才可以正常扫地</p>
<p>在这个例子上,我们知道,如果只是给你一个线程,是无法和你一起执行的,你要扫大厅,还是要你自己去扫,所以你必须先扫卧室在扫大厅,当然你可以反过来,看你什么时候调用,此时打扫完成2个房间需要20分钟,这个就是调用run方法的效果,但是,如果你调用的是start()方法,那就好比你拿到一个扫地机器人后,先给他充电,充满电之后,你可以和它一起打扫2个房间,此时打扫房间只需要花费10分钟,因为你们是同时打扫的,你打扫卧室,它打扫大厅,这个就是start()方法和run()方法的区别,同时也是为什么我们要调用start()方法而不是调用run()方法</p>
<p>我们可以通过以下代码来验证一下</p>
<p>我们先看第一个,如果是调用run()方法的情况</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).run();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>此时的运行结果如下:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162542899.png" alt="image-20200318162542899" loading="lazy"></figure>
<p>我们发现,打扫卧室的是main线程,打扫大厅的实际也是main线程,说明打扫打扫着两个房间是同一个线程,而且打扫每个房间需要1秒,打扫2个房间一个花了2秒</p>
<p>那么如果将run()改成start()方法呢?会需要几秒打扫2个房间呢?我们看改完之后的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>我们将run()改成start()方法之后,我们来看一下运行的结果:</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162845172.png" alt="image-20200318162845172" loading="lazy"></figure>
<p>我们可以看到第一,打扫大厅和打扫卧室的不是同一个线程,说明确实有两个线程(主人+扫地机器人)在打扫房间,另外打扫完成一个花了1秒钟,说明这两个房间确实是同时在打扫的</p>
<p>那么现在,你确实知道为什么要调用start()而不用run()方法了吗?</p>
<p>还有上面的第二个问题,这个*程序的运行结果是什么?*这个问题就是上面的运行结果,你了解了吗?</p>
]]></content>
    </entry>
</feed>