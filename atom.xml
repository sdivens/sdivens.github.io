<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sdivens.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-21T08:02:08.059Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sdivens.github.io"/>
    <link rel="self" href="https://sdivens.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://sdivens.github.io/images/avatar.png</logo>
    <icon>https://sdivens.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[BIO阻塞模式网络编程(中)]]></title>
        <id>https://sdivens.github.io/post/net-bio-2/</id>
        <link href="https://sdivens.github.io/post/net-bio-2/">
        </link>
        <updated>2020-03-21T07:59:40.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
<!-- more -->
<h1 id="优化">优化</h1>
<p><a href="https://sdivens.github.io/post/net-bio-1">之前</a>我们已经了解了如果使用java进行BIO网络编程,但是那种会有很大的性能问题,我们可以采用多线程的方式优化这段代码,如何优化呢?我们来看新的代码</p>
<pre><code class="language-java">    static class BIOServer{
        private static ExecutorService executorService = Executors.newCachedThreadPool();

        public static void main(String[] args) {

            // 启动服务
            ServerSocket server;
            try {
                 server = new ServerSocket(8080);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            System.out.println(&quot;服务启动成功&quot;);

            // 如果服务没有关闭,则不断接受新的客户端连接
            while (!server.isClosed()) {
                Socket request;
                try {
                    // accept是一个阻塞方法,会如果没有新的连接,会一直在这行等着
                    request = server.accept();
                } catch (IOException e) {
                    e.printStackTrace();
                    continue;
                }
                System.out.println(&quot;收到新连接: &quot;+request.toString());
                // 接收到新连接之后,通过线程池开启新线程去打印客户端的请求
                executorService.execute(() -&gt;{
                    InputStream input;
                    BufferedReader reader;
                    try {
                        input = request.getInputStream();
                        reader = new BufferedReader(new InputStreamReader(input, &quot;utf-8&quot;));
                        String msg;
                        // 在这里,如果reader.readLine没有数据,也会被阻塞
                        while ((msg = reader.readLine()) != null) {
                            if (StringUtils.isEmpty(msg)){
                                break;
                            }
                            System.out.println(String.format(&quot;收到来自%s的数据,数据内容为:&quot;, request.toString()));
                            System.out.println(msg);
                        }
                    } catch (IOException e) {
                        e.printStackTrace();
                    }finally {
                        // 关闭请求
                        try {
                            request.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                });

            }
            // 关闭服务
            try {
                server.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    static class BIOClient{
        public static void main(String[] args) {
            // 创建客户端连接到服务器的8080端口
            Socket socket;
            try {
                 socket= new Socket(&quot;localhost&quot;, 8080);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // 向服务器传输信息
            OutputStream outputStream;
            try {
                outputStream = socket.getOutputStream();
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            Scanner scanner = new Scanner(System.in);
            System.out.println(&quot;请输入要向服务器传输的信息:&quot;);
            String msg = scanner.nextLine();
            try {
                // write方法会一直阻塞,知道msg的内容写完了为止,所以如果msg的内容很多,会一直阻塞在这
                outputStream.write(msg.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            // 关闭scanner
            scanner.close();
            try {
                // 关闭客户端连接
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>在新的代码中,客户端的代码与之前没有改动,主要是服务端的优化,服务端主要是优化了哪部分呢?</p>
<p>首先,我们在服务端加了一个线程池<code>private static ExecutorService executorService = Executors.newCachedThreadPool()</code>,这个线程池主要用来干什么呢?主要是用来在接收到客户端的请求之后,将打印客户端请求内容的工作交给了线程池来做</p>
<pre><code class="language-java">// 接收到新连接之后,通过线程池开启新线程去打印客户端的请求
executorService.execute(() -&gt;{
    InputStream input;
    BufferedReader reader;
    try {
        input = request.getInputStream();
        reader = new BufferedReader(new InputStreamReader(input, &quot;utf-8&quot;));
        String msg;
        // 在这里,如果reader.readLine没有数据,也会被阻塞
        while ((msg = reader.readLine()) != null) {
            if (StringUtils.isEmpty(msg)){
                break;
            }
            System.out.println(String.format(&quot;收到来自%s的数据,数据内容为:&quot;, request.toString()));
            System.out.println(msg);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }finally {
        // 关闭请求
        try {
            request.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
});
</code></pre>
<p>可以看到,接收到新连接之后,通过线程池开启新线程去打印客户端的请求.这样呢主线程可以继续接收下一个客户端的连接了,提高了服务器的处理效率,我们来看运行结果</p>
<p>我们还是运行一个服务端和两个客户端来看效果</p>
<p>首先启动一个服务端</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321152449846.png" alt="image-20200321152449846" loading="lazy"></figure>
<p>我们的服务端已经启动成功了,我们在启动客户端1</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321152522744.png" alt="image-20200321152522744" loading="lazy"></figure>
<p>客户端1已经启动起来了,最后启动客户端2</p>
<figure data-type="image" tabindex="3"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321152553299.png" alt="image-20200321152553299" loading="lazy"></figure>
<p>现在一个服务端和2个客户端都已经启动起来了,我们在来看服务端有没有接收到这两个客户端</p>
<blockquote>
<p>在<a href="https://sdivens.github.io/post/net-bio-1">之前</a>的代码中,启动两个客户端后服务端只打印了一个客户端的信息,是因为在客户端1没有像服务端传输信息的情况下,被<code>reader.readLine()</code>这个代码阻塞住了,所以没有收到第二个客户端的请求</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321154705695.png" alt="image-20200321154705695" loading="lazy"></figure>
<p>我们可以看到在客户端没有向服务端发送请求的情况下服务端已经收到了2个客户端的请求</p>
<p>现在通过客户端1发送一个请求试试</p>
<figure data-type="image" tabindex="5"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321154740627.png" alt="image-20200321154740627" loading="lazy"></figure>
<p>可以看到服务端已经接受并打印了客户端1的请求</p>
<p>再通过客户端2发送请求试一下</p>
<figure data-type="image" tabindex="6"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321154841307.png" alt="image-20200321154841307" loading="lazy"></figure>
<p>同样,服务端也接收并打印了客户端2的请求</p>
<h1 id="与优化前比较">与优化前比较</h1>
<p>在<a href="https://sdivens.github.io/post/net-bio-1">之前</a>的文章中问过一个问题:过如果客户端1比客户端2先连上,但是客户端2先发送消息,然后再是客户端1发送信息,那么结果是什么?我们运行之前文章的代码,然后来看运行结果</p>
<figure data-type="image" tabindex="7"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153655606.png" alt="image-20200321153655606" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153707656.png" alt="image-20200321153707656" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153719099.png" alt="image-20200321153719099" loading="lazy"></figure>
<p>启动一个服务端和2个客户端,现在已经客户端1已经连接上了服务器端了</p>
<figure data-type="image" tabindex="10"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153757656.png" alt="image-20200321153757656" loading="lazy"></figure>
<p>这个时候如果客户端1发送消息的话结果大家已经知道了,现在我们先通过客户端2来发送信息,来看看结果如何</p>
<figure data-type="image" tabindex="11"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153912883.png" alt="image-20200321153912883" loading="lazy"></figure>
<p>我们看到客户端2的信息已经发送了,那么服务端有没有接收到呢?难道数据丢失了吗?</p>
<figure data-type="image" tabindex="12"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321153941880.png" alt="image-20200321153941880" loading="lazy"></figure>
<p>???信息呢?没有接收到吗?我们再通过客户端1发送一条信息试试</p>
<figure data-type="image" tabindex="13"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321154117001.png" alt="image-20200321154117001" loading="lazy"></figure>
<p>我买可以看到数据并没有丢失,但是客户端2的消息是在客户端1处理完成之后再处理的</p>
<p>我们再在今天优化过后的代码中试一下</p>
<p>同样,我们启动一个服务端和2个客户端,现在都已经启动好了</p>
<figure data-type="image" tabindex="14"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321155206721.png" alt="image-20200321155206721" loading="lazy"></figure>
<p>我们先通过客户端2发送请求,客户端2是<code>port=62274</code>的请求端</p>
<figure data-type="image" tabindex="15"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321155258089.png" alt="image-20200321155258089" loading="lazy"></figure>
<p>我们可以看到,客户端2的内容直接被打印了,并没有等待客户端1处理完成,所以这个比之前的代码性能更优,我们再通过客户端1发送请求</p>
<figure data-type="image" tabindex="16"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(%E4%B8%AD)/image-20200321155438893.png" alt="image-20200321155438893" loading="lazy"></figure>
<p>同样可以被服务端打印输出</p>
<h1 id="总结">总结</h1>
<p>最后总结一下,我们通过在原来代码的基础上通过多线程的方式对原来的代码进行优化处理,成功的提升了服务端的处理性能</p>
<h1 id="最后">最后</h1>
<p>这个程序还可以继续优化吗?<br>
当然.....可以,我们虽然用到了线程池提高了成功的处理能力,但是有大量请求来的时候,我们会开启很多的子线程,每一个子线程都会消耗系统资源,最重要的是,子线程并没有被有效的利用起来,而是在不断的阻塞等待客户端的输入,这样极大的浪费了系统的资源</p>
<p>那么,又要如何优化呢?</p>
<p>请看下回分解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BIO阻塞模式网络编程(上)]]></title>
        <id>https://sdivens.github.io/post/net-bio-1/</id>
        <link href="https://sdivens.github.io/post/net-bio-1/">
        </link>
        <updated>2020-03-21T07:01:39.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
<!-- more -->
<p><a href="https://sdivens.github.io/post/internet-tcpandudp">上次</a>我们介绍了TCP和UDP以及Socket编程的一些知识,那么java中如何使用socket进行网络编程呢?今天介绍一个java中进行网络编程的方式:<strong>BIO阻塞模式网络编程</strong></p>
<h1 id="概念">概念</h1>
<p><strong>BIO阻塞模式网络编程</strong>从名字上可以看这是一种阻塞方式的网络编程,BIO指的是blocking-io,是java中提供的一种网络编程方式,那么这种BIO阻塞模式网络编程如何使用呢?我们主要是通过以两个类来实现</p>
<ol>
<li>ServerSocket(服务端)</li>
<li>Socket(客户端)</li>
</ol>
<p>来我们看代码</p>
<pre><code class="language-java">public class BIODemo {
    static class BIOServer{
        public static void main(String[] args) {
            // 启动服务
            ServerSocket server;
            try {
                 server = new ServerSocket(8080);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            System.out.println(&quot;服务启动成功&quot;);

            // 如果服务没有关闭,则不断接受新的客户端连接
            while (!server.isClosed()) {
                Socket request;
                try {
                    // accept是一个阻塞方法,会如果没有新的连接,会一直在这行等着
                    request = server.accept();
                } catch (IOException e) {
                    e.printStackTrace();
                    continue;
                }
                System.out.println(&quot;收到新连接: &quot;+request.toString());
                // 收到连接后打印请求数据
                InputStream input;
                BufferedReader reader;
                try {
                    input = request.getInputStream();
                    reader = new BufferedReader(new InputStreamReader(input, &quot;utf-8&quot;));
                    String msg;
                    // 在这里,如果reader.readLine没有数据,也会被阻塞
                    while ((msg = reader.readLine()) != null) {
                        if (StringUtils.isEmpty(msg)){
                            break;
                        }
                        System.out.println(String.format(&quot;收到来自%s的数据,数据内容为:&quot;, request.toString()));
                        System.out.println(msg);
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                    continue;
                }finally {
                    // 关闭请求
                    try {
                        request.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            // 关闭服务
            try {
                server.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    static class BIOClient{
        public static void main(String[] args) {
            // 创建客户端连接到服务器的8080端口
            Socket socket;
            try {
                 socket= new Socket(&quot;localhost&quot;, 8080);
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }

            // 向服务器传输信息
            OutputStream outputStream;
            try {
                outputStream = socket.getOutputStream();
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            Scanner scanner = new Scanner(System.in);
            System.out.println(&quot;请输入要向服务器传输的信息:&quot;);
            String msg = scanner.nextLine();
            try {
                // write方法会一直阻塞,知道msg的内容写完了为止,所以如果msg的内容很多,会一直阻塞在这
                outputStream.write(msg.getBytes());
            } catch (IOException e) {
                e.printStackTrace();
                return;
            }
            // 关闭scanner
            scanner.close();
            try {
                // 关闭客户端连接
                socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<p>在这里我们定义了一个服务端<code>BIOServer</code>和一个客户端<code>BIOClient</code>两个类,首先是通过<code>new ServerSocket(8080);</code>来启动服务和绑定端口8080,然后可以通过<code>server.accept();</code>来接收客户端的请求,注意,<strong><code>server.accept()</code>是阻塞方法</strong>,如果没有请求,会一直阻塞在这行.当客户端发来请求之后,我们可以获取客户端向服务端发送的内容并打印出来</p>
<pre><code class="language-java">input = request.getInputStream();
reader = new BufferedReader(new InputStreamReader(input, &quot;utf-8&quot;));
String msg;
// 在这里,如果reader.readLine没有数据,也会被阻塞
while ((msg = reader.readLine()) != null) {
    if (StringUtils.isEmpty(msg)){
        break;
    }
    System.out.println(String.format(&quot;收到来自%s的数据,数据内容为:&quot;, request.toString()));
    System.out.println(msg);
}
</code></pre>
<p>这部分代码就是获取并打印客户端的请求数据,其中<code>reader.readLine()</code>也是<strong>阻塞方法</strong>,如果没有获取到客户端的发送内容,会一直阻塞在这里,我们可以来运行一下,看一下结果</p>
<p>我们启动一个服务器,然后启动两个客户端</p>
<p>先启动服务器</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321144735530.png" alt="image-20200321144735530" loading="lazy"></figure>
<p>好,服务器已经启动成功了,我们在启动客户端1</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321144813149.png" alt="image-20200321144813149" loading="lazy"></figure>
<p>再启动客户端2</p>
<figure data-type="image" tabindex="3"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321144832983.png" alt="image-20200321144832983" loading="lazy"></figure>
<p>现在我们看到我们已经启动了一个服务器和两个客户端程序,我们在来看服务器端有没有收到客户端的两个请求</p>
<figure data-type="image" tabindex="4"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321144924393.png" alt="image-20200321144924393" loading="lazy"></figure>
<p>我们可以看到服务器上已经收到了客户端的请求,但是为什么只有一个请求呢?客户端2的请求在哪?</p>
<p>不要着急,还记得之前说过<code>reader.readLine()</code>这个方法也是一个阻塞方法吗?我们的代码中收到一个请求之后,再打印客户发送的请求,现在客户端1连上了服务器,但是没有发送请求过来,所以服务端现在被阻塞在了<code>reader.readLine()</code>这一行代码这个地方,我们现在只需要通过客户端1像服务器发送一条消息,服务器就可以打印这条信息后然后循环接收下一个客户端连接,我们来试一下</p>
<figure data-type="image" tabindex="5"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321145331570.png" alt="image-20200321145331570" loading="lazy"></figure>
<p>我们通过客户端1向服务器发送了一条<em>客户端1</em>的内容,然后我们再看服务器端有没有收到这条消息,以及收到消息后有没有收到客户端2的连接</p>
<figure data-type="image" tabindex="6"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321145450624.png" alt="image-20200321145450624" loading="lazy"></figure>
<p>果然,我们可以看到服务器端接收了客户端1的请求,并且打印了请求内容,而且服务器也成功接收到了第二个客户端的请求,现在我们通过客户端2再向服务器发送一条信息.</p>
<figure data-type="image" tabindex="7"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321145623420.png" alt="image-20200321145623420" loading="lazy"></figure>
<p>客户端2向服务器发送请求之后,我们在看服务器有没有收到消息</p>
<figure data-type="image" tabindex="8"><img src="https://sdivens.github.io/post-images/BIO%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200321145708756.png" alt="image-20200321145708756" loading="lazy"></figure>
<p>我们可以看到服务器已经成功接收到了客户端2发送的请求</p>
<p>好了,以上就是java中BIO阻塞网络编程的基础使用方法了,但是这种方式有很大的弊端,相信很多人都已经知道了,那就是性能问题,服务器一次只能请求一个客户端的请求,如果一个请求耗时比较多的话,其他的请求会都阻塞等待.那么有什么办法可以优化这个代码呢?提示一下:可以使用多线程的方式优化这段代码,如何采用多线程的方式优化这段代码呢?请看下回分解</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程通信]]></title>
        <id>https://sdivens.github.io/post/thread-notice/</id>
        <link href="https://sdivens.github.io/post/thread-notice/">
        </link>
        <updated>2020-03-20T07:59:44.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<h1 id="什么是线程通信">什么是线程通信</h1>
<p>线程通信是指多线程之间进行的数据交换</p>
<h1 id="为什么需要线程通信">为什么需要线程通信</h1>
<p>要想实现多个线程之间的协同,比如线程之间执行的先后顺序,获取某个线程的执行结果等等,这些都涉及到了线程之间的相互通信,举个例子</p>
<blockquote>
<p>早上卖包子的店子前面排了很长的队伍,但是这个时候包子卖完了,这个时候包子店的老板就想知道后厨的新鲜的包子出炉没有,包子店的老板可能会通过打电话问后厨的厨师包子是否已经做好了.这个时候,我们说卖包子的老板是一个线程,负责卖包子,后厨的厨师是一个线程,负责生产包子,他们之间各自负责各自的事情,但是又不是毫无关系的,他们之间需要通信,这个通信就是为了获取厨师这个线程的执行结果</p>
</blockquote>
<h1 id="线程之间如何通信">线程之间如何通信</h1>
<h2 id="线程通信的方式">线程通信的方式</h2>
<p>线程之间通信的方式有四类</p>
<ol>
<li>文件共享</li>
<li>网络共享</li>
<li>共享变量</li>
<li>JDK提供的线程协调API</li>
</ol>
<h3 id="文件共享">文件共享</h3>
<p>文件共享指的是一个线程往文件里边写数据,另外一个线程往里边读数据,以此实现了线程通信</p>
<h3 id="网络共享">网络共享</h3>
<p>网络共享和文件共享类似</p>
<h3 id="共享变量">共享变量</h3>
<p>变量共享是通过线程共享的内存区域(堆,常量池等)的变量进行修改和读取来实现线程之间的通信</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320141744014.png" alt="image-20200320141744014" loading="lazy"></figure>
<p>比如线程1修改变量content的内容为100,线程2就就可以读到这个100,以此达到了线程之间通信的目的</p>
<h3 id="线程协作-jdk-api">线程协作 JDK API</h3>
<p>JDK中对于需要多线程协作完成某一任务的场景,提供了对应的API支持</p>
<p>多线程协作的典型场景就是生产者-消费者模型(线程阻塞-线程唤醒)</p>
<p>示例:线程一去买包子,没有包子,则等待,线程二生产出包子了,在通知线程一继续执行</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320142302300.png" alt="image-20200320142302300" loading="lazy"></figure>
<p>JDK中有一下一些API</p>
<ol>
<li>suspend和resume</li>
<li>wait和notify/notifyall</li>
<li>park/unpark</li>
</ol>
<p>我们一个一个讲</p>
<h4 id="被弃用的api-suspend和resume">被弃用的API suspend和resume</h4>
<h5 id="作用">作用</h5>
<p>suspend挂起目标线程,通过resume可以恢复线程执行</p>
<h5 id="如何使用suspend和resume">如何使用suspend和resume</h5>
<p>我们来看代码</p>
<pre><code class="language-java">public class SuspendResumeDemo {
    public static Object baozi = null;

    public static void main(String[] args) {
        Thread buyBaozi = new Thread(() -&gt; {
            if (baozi == null) {
                System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                Thread.currentThread().suspend();
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        });
        buyBaozi.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (baozi == null) {
            System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
            baozi = new Object();
            System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
            buyBaozi.resume();
        }
    }
}
</code></pre>
<p>这是 一个典型的消费者生产者模式的例子,线程一去买包子,没有包子,则等待,线程二生产出包子了,在通知线程一继续执行,可以看到运行结果如下:</p>
<pre><code>买包子的人:没有包子了,等一等吧
包子店:包子卖完了,赶紧生产包子
包子店:包子生产完了,告诉买包子的人有包子了
买包子的人:买到包子了,回家
</code></pre>
<h5 id="为什么被弃用">为什么被弃用?</h5>
<p>被弃用的主要原因是容易写出死锁的代码,所以用wait/notify和park/unpark所替代,那么为什么容易写出死锁的代码呢?</p>
<ol>
<li>suspend挂起之后不会释放锁</li>
<li>suspend一定要比resume先执行,如果比resume后执行,就会发生死锁</li>
</ol>
<p>第一点,suspend挂起之后不会释放锁,那么如果在同步代码块synchronized中写suspend的的代码,就很容易发生死锁,我们来看下边这段代码</p>
<pre><code class="language-java">public class SuspendResumeDemo {
    public static Object baozi = null;

    public static void main(String[] args) {
        SuspendResumeDemo demo = new SuspendResumeDemo();
        demo.suspendResumeTest();
    }
    public void suspendResumeTest() {
        Thread buyBaozi = new Thread(() -&gt; {
            synchronized (this) {
                if (baozi == null) {
                    System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                    Thread.currentThread().suspend();
                }
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        });
        buyBaozi.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (baozi == null) {
            System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
            baozi = new Object();
            synchronized (this) {
                System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
                buyBaozi.resume();
            }
        }
    }
}
</code></pre>
<p>这段代码中,<code>Thread.currentThread().suspend();</code>和<code>buyBaozi.resume();</code>都是在<code>synchronized</code>代码块中的,那么<code>buyBaozi</code>这个线程通过<code>Thread.currentThread().suspend()</code>挂起了线程,但是没有释放锁,那么主线程在执行<code>buyBaozi.resume();</code>通知<code>buyBaozi</code>的时候要先获取这把锁,但是获取不到(因为锁还在<code>buyBaozi</code>自己手上),所以造成了死锁,永远也唤醒不了<code>buyBaozi</code>这个线程,执行结果如下:</p>
<figure data-type="image" tabindex="3"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320144738500.png" alt="image-20200320144738500" loading="lazy"></figure>
<p>第二点,suspend一定要比resume先执行,如果比resume后执行,就会发生死锁,我们来看代码</p>
<pre><code class="language-java">public class SuspendResumeDemo {
    public static Object baozi = null;

    public static void main(String[] args) {
        SuspendResumeDemo demo = new SuspendResumeDemo();
        demo.suspendResumeTest();
    }
    public void suspendResumeTest() {
        Thread buyBaozi = new Thread(() -&gt; {
            if (baozi == null) {
                System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                Thread.currentThread().suspend();
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        });
        buyBaozi.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if (baozi == null) {
            System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
            baozi = new Object();
            System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
            buyBaozi.resume();
        }

    }
}
</code></pre>
<p>在这段代码中,生产包子只花了3秒,而买包子的人等了5秒,就会导致<code>buyBaozi.resume();</code>在<code>Thread.currentThread().suspend();</code>之前执行,这样也会发生死锁,<code>baozi</code>这个线程永远不会被唤醒了,我们来看执行结果</p>
<figure data-type="image" tabindex="4"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320145328932.png" alt="image-20200320145328932" loading="lazy"></figure>
<p>同样的结果,所以不推荐使用suspend和resume</p>
<h4 id="waitnotify机制">wait/notify机制</h4>
<h5 id="介绍">介绍</h5>
<p>wait方法会导致当前线程等待,加入该对象的等待集合中,并且放弃该对象持有的锁,notify/notifyall方法会唤醒一个或所有正在等待这个对象锁的线程</p>
<p>这些方法只有由同一个对象锁的持有者线程调用,也就是必须写在同步代码块synchronized中,否则会抛出<code>IllegalMonitorStateException</code>异常</p>
<p>也就是说,调用wait方法的线程和调用notify/notifyall方法的线程必须在synchronized中,并且持有的是同一个锁,如果调用notify方法的线程持有的锁和调用wait方法的线程持有的锁不是同一个,也不可以调用</p>
<blockquote>
<p><em>注意</em>:wait方法虽然会释放锁,但是对于<strong>调用的顺序也是有要求的</strong>,如果先调用线程的notify,线程才调用wait(和上边的suspend和resume一样),那么线程同样会一直进入WAITTING状态</p>
</blockquote>
<h5 id="为什么使用waitnotify机制">为什么使用wait/notify机制</h5>
<p>因为wait会自动释放锁,不会容易造成死锁,比之前的suspend和resume更安全</p>
<h5 id="如何使用waitnotify">如何使用wait/notify</h5>
<p>看代码</p>
<pre><code class="language-java">public class WaitNotifyDemo {
    public static Object baozidian = null;

    public static void main(String[] args) throws Exception {
        WaitNotifyDemo demo = new WaitNotifyDemo();
        demo.waitNotifyTest();
    }

    public void waitNotifyTest() throws Exception {
        // 启动线程
        new Thread(() -&gt; {
            synchronized (this) {
                while (baozidian == null) { // 如果没包子，则进入等待
                    try {
                        System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        }).start();
        // 3秒之后，生产一个包子
        Thread.sleep(3000L);
        System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
        baozidian = new Object();
        synchronized (this) {
            this.notifyAll();
            System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
        }
    }

}
</code></pre>
<p>这个是正常使用wait和notify的情况,在这个里边我们要注意一点,那就是<code>this.wait()</code>和<code>this.notifyAll()</code>必须是在<code>synchronized</code>包裹中. 我们来看执行结果如下:</p>
<pre><code>买包子的人:没有包子了,等一等吧
包子店:包子卖完了,赶紧生产包子
包子店:包子生产完了,告诉买包子的人有包子了
买包子的人:买到包子了,回家
</code></pre>
<p>既然有正常使用的情况,那肯定有不正常使用的情况,我们之前说过,wait虽然可以自动释放锁,但是必须在notify和notifyall方法之前调用,如果先调用notify/notifyall,再调用wait,那么会导致调用wait方法是线程永远处于WAITING状态,但是锁会被释放,我们来看代码</p>
<pre><code class="language-java">public class WaitNotifyDemo {
    public static Object baozidian = null;

    public static void main(String[] args) throws Exception {
        WaitNotifyDemo demo = new WaitNotifyDemo();
        demo.waitNotifyDeadLockTest();
    }

    public void waitNotifyDeadLockTest() throws Exception {
        // 启动线程
        new Thread(() -&gt; {
            if (baozidian == null) { // 如果没包子，则进入等待
                try {
                    System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                    Thread.sleep(5000L);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
                synchronized (this) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        }).start();
        // 3秒之后，生产一个包子
        Thread.sleep(3000L);
        System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
        baozidian = new Object();
        synchronized (this) {
            this.notifyAll();
            System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
        }
    }
}
</code></pre>
<p>在这个代码中,3秒后会执行<code>this.notifyAll();</code>,然而5秒后才会执行<code>this.wait();</code>,所以是先执行notify/notifyall,再执行wait,这样会导致调用wait方法的线程永远进入WAITING状态,但是锁是会被释放出来,我们来看执行结果</p>
<figure data-type="image" tabindex="5"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320151701413.png" alt="image-20200320151701413" loading="lazy"></figure>
<p>买包子的线程永远不会停止.但是锁释放出来了,接下来我们说另一个API</p>
<h4 id="parkunpark机制">park/unpark机制</h4>
<h5 id="介绍-2">介绍</h5>
<p>park和unpark机制可以看成是通行证或者许可证机制,有通行证就可以获得锁,没有通行证就不能获得锁</p>
<p>park方法可以看成是去某个地方获取通行证,而unpark是将通行证放在某个地方.这样做的好处是什么?</p>
<h5 id="为什么要使用parkunpark机制">为什么要使用park/unpark机制</h5>
<p>就是可以<strong>解决以上两种API方式都有的问题:顺序问题</strong>.在suspend/resume和wait/notify中都有顺序问题,那就是必须先调用等待方法,在调用唤醒方法,否则要么容易死锁,要么线程永远处于WAITING状态.park/unpark则不通,可以先调用park等待获取通行证,然后调用park将通行证送过来,也可以先调用unpark将通行证送过来放在这,过一会如果park方法过来取通行证的话,可以直接取走,不用再等待了,<strong>不要求park/unpark的调用顺序</strong>,但是,<strong>unpark不能叠加</strong>,就是说,如果连续调用3次unpark方法,让后在连续调用3次park方法,那么第一次park会直接获取通行证继续执行,但是第二次和第三次会永远进入WAITTING状态</p>
<h5 id="parkunpark如何使用">park/unpark如何使用</h5>
<p>先看正常使用的代码</p>
<pre><code class="language-java">public class ParkUnparkDemo {
    public static Object baozidian = null;

    public static void main(String[] args) throws Exception {
        ParkUnparkDemo demo = new ParkUnparkDemo();
        demo.parkUnparkTest();
    }

    public void parkUnparkTest() throws Exception {
        // 启动线程
        Thread consumerThread = new Thread(() -&gt; {
            while (baozidian == null) { // 如果没包子，则进入等待
                System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                LockSupport.park();
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        });
        consumerThread.start();
        // 3秒之后，生产一个包子
        Thread.sleep(3000L);
        System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
        baozidian = new Object();
        LockSupport.unpark(consumerThread);
        System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
    }
}
</code></pre>
<p>先调用<code>LockSupport.park()</code>让线程挂起,然后在调用<code>LockSupport.unpark(consumerThread)</code>唤醒<code>consumerThread</code>这个线程,注意,unpark方法中需要传入一个参数,这个参数就是你指定的需要唤醒的线程,在这个例子中是<code>consumerThread</code>这个线程</p>
<p>我们来看运行的结果:</p>
<pre><code class="language-买包子的人:没有包子了,等一等吧">买包子的人:没有包子了,等一等吧
包子店:包子卖完了,赶紧生产包子
包子店:包子生产完了,告诉买包子的人有包子了
买包子的人:买到包子了,回家
</code></pre>
<p>既然有正常使用的方式,肯定有非正常使用的方式,我们来看不正常的使用方式</p>
<pre><code class="language-java">public class ParkUnparkDemo {
    public static Object baozidian = null;

    public static void main(String[] args) throws Exception {
        ParkUnparkDemo demo = new ParkUnparkDemo();
        demo.parkUnparkDeadLockTest();
    }

    public void parkUnparkDeadLockTest() throws Exception {
        // 启动线程
        Thread consumerThread = new Thread(() -&gt; {
            if (baozidian == null) { // 如果没包子，则进入等待
                System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
                // 当前线程拿到锁，然后挂起
                synchronized (this) {
                    LockSupport.park();
                }
            }
            System.out.println(&quot;买包子的人:买到包子了,回家&quot;);
        });
        consumerThread.start();
        // 3秒之后，生产一个包子
        Thread.sleep(3000L);
        System.out.println(&quot;包子店:包子卖完了,赶紧生产包子&quot;);
        baozidian = new Object();
        // 争取到锁以后，再恢复consumerThread
        synchronized (this) {
            LockSupport.unpark(consumerThread);
        }
        System.out.println(&quot;包子店:包子生产完了,告诉买包子的人有包子了&quot;);
    }
}
</code></pre>
<p>在上面的代码中,我们在<code>LockSupport.park();</code>和<code>LockSupport.unpark(consumerThread);</code>上都添加了<code>synchronized</code>同步代码块,那么造成的结果是什么呢? 我们来看运行结果:</p>
<figure data-type="image" tabindex="6"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20200320154233037.png" alt="image-20200320154233037" loading="lazy"></figure>
<p>结果就是,造成了<em>死锁</em>,聪明的朋友应该已经知道了原因:因为<strong>park/unpark不会自动释放锁</strong></p>
<p>最后我们总结一下:</p>
<table>
<thead>
<tr>
<th>JDK API</th>
<th>是否自动释放锁</th>
<th>是否要求顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td>suspend/resume</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>wait/notify</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>park/unpark</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<h4 id="伪唤醒">伪唤醒</h4>
<h5 id="什么是伪唤醒">什么是伪唤醒?</h5>
<p>伪唤醒是处于等待状态的线程可能会受到错误警报和伪唤醒,这个伪唤醒是一个很底层的原因,设计到CPU以及操作系统的一些调度,我们只要知道有伪唤醒这个不确定因素就好了</p>
<p>伪唤醒是指<em>线程并非由notify/notifyall/resume/unpark等API调用而唤醒,而是更底层的原因导致的</em></p>
<h5 id="如何避免伪唤醒">如何避免伪唤醒</h5>
<p>为了避免处于等待状态的线程被不正常的唤醒(伪唤醒),所以我们之前的代码中的<code>if</code>条件判断语句最好改成<code>while</code>循环语句来判断,比如之前判断包子没有了的代码:</p>
<pre><code class="language-java">if (baozidian == null) { // 如果没包子，则进入等待
    try {
        System.out.println(&quot;买包子的人:没有包子了,等一等吧&quot;);
        Thread.sleep(5000L);
    } catch (InterruptedException e1) {
        e1.printStackTrace();
    }
    synchronized (this) {
        try {
            this.wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>我们可以将<code>if (baozidian == null)</code>改成<code>while (baozidian == null)</code>,其他的判断也是一样的,这样的好处是,在<code>this.wait()</code>这个地方如果被伪唤醒了,会再一次进入到循环判断包子是否已经有了,如果还是没有,那么线程会继续调用<code>this.wait()</code>然后进入等待,如果包子已经有了,那么就不会再进入这个循环体了,可以去执行自己的事情(买到包子,回家)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP&UDP协议]]></title>
        <id>https://sdivens.github.io/post/internet-tcpandudp/</id>
        <link href="https://sdivens.github.io/post/internet-tcpandudp/">
        </link>
        <updated>2020-03-19T09:01:54.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
<!-- more -->
<h1 id="osi网络七层模型">OSI网络七层模型</h1>
<h2 id="概念">概念</h2>
<p>为了让不同计算机厂家的计算机能够互相通信,以便在更大范围内进行通信,有必要建立一个国际范围的网络体系结构标准</p>
<p>网络七层模型是哪七层呢?从上到下分别是:</p>
<ol>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<p>我们看以下示例图:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319142811887.png" alt="image-20200319142811887" loading="lazy"></figure>
<p>这个是OSI网络七层模型</p>
<h2 id="为什么要弄这七层模型呢">为什么要弄这七层模型呢</h2>
<p>其中一个原因是可以每个层单独处理,比如做网线的,就只要处理物理层的内容,而不用关心整个的网络结构</p>
<h2 id="各个层次的主要功能">各个层次的主要功能</h2>
<p>首先是低三层,哪三层是低三层呢?</p>
<h3 id="低三层">低三层</h3>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ol>
<p>物理层主要是使原始的数据比特流能够在物理介质上传输</p>
<blockquote>
<p>这句话的意思是怎么样才可以让电流,光等这些电信号,光信号能够在光纤的两端进行通信</p>
</blockquote>
<p>数据链路层主要是通过校验,确认,反馈,重发等手段,形成稳定的数据链路</p>
<blockquote>
<p>这句话的意思是,通过物理层发送的信号可能会有丢失等各种情况,数据链路层为了防止丢失数据还不知道,所以有数据校验,确认,反馈等,发送方如果确认数据丢失,需要重发等</p>
</blockquote>
<p>所以物理层和数据链路层主要是解决了两个端点之间(比如说一根网线的两端)的通信问题,那么我们说网络是有很多节点的</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319144438330.png" alt="image-20200319144438330" loading="lazy"></figure>
<p>那么像网络这么复杂的节点,A需要发送一个数据,那么怎么知道发送到哪个机器上去呢?这个就是网络层要解决的事情</p>
<p>网络层提供了一个互联网之间数据链路上的<strong>逻辑链接</strong>,比如说IP协议,通过ip可以定位到正确的数据目的地,比如我们要发送一个数据,这个数据要发给谁?我们需要通过ip定位到这个目的的地址,从而通过网络层的技术,将一个节点的数据发送到另外一个节点</p>
<blockquote>
<p>如果我们要邮寄一封信件,我们需要在信上填写准确的收信地址(ip地址),然后给到邮局(服务器),通过邮局派发的送信员送到目的地,其中发送方是发件人,接收方是收件人,信息是信件,链路是公路或者乡村小路</p>
</blockquote>
<p>以上就是低三层,低三层的目的是为了<strong>屏蔽底层网络的复杂性</strong>,我们作为java开发等后端开发人员,是不需要太过于关注低三层</p>
<h3 id="中间层">中间层</h3>
<p>传输层是中间层,承上启下,主要提供了<strong>可靠的</strong> <strong>端口到端口的</strong>数据传输服务(TCP/UDP协议)</p>
<p>我们说之前ip地址提供了网络之间访问到某个机器的地址,但是他没法提供具体的端口,TCP/TDP协议就是对具体传输层的定义,我们的网络应用大多是基于传输层开发的,所以了解传输层(TCP/UDP)对于我们开发网络应用是很有帮助的</p>
<h3 id="高三层">高三层</h3>
<ol>
<li>会话层 负责建立,管理和终止进程之间的会话和数据交换</li>
<li>表示层 负责数据格式转换,数据加密解密,压缩与解压缩等</li>
<li>应用层 为用户的应用进程提供网络服务</li>
</ol>
<p>可以将这三层看成是一个应用层,比如HTPP服务器,他实现了高三层的功能</p>
<p>比如说会话层是关闭连接和建立连接的过程,表示层是https或者md5等相关的处理,http本身也是一种协议,是基于tcp开发的针对于web服务的协议</p>
<p>我们主要了解传输层与应用层</p>
<h2 id="传输控制协议tcp">传输控制协议TCP</h2>
<p>传输控制协议(TCP)提供了一个服务,这个服务有以下特点</p>
<ol>
<li>面向连接</li>
<li>可靠</li>
<li>有序</li>
<li>字节流传输</li>
</ol>
<p>应用程序在使用TCP之前,必须先建立TCP连接,建立连接需要要一个tcp报文,报文结构如下:</p>
<figure data-type="image" tabindex="3"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319152117553.png" alt="image-20200319152117553" loading="lazy"></figure>
<p>对于tcp连接需要有几个特点需要了解</p>
<h3 id="三次握手">三次握手</h3>
<p>三次握手的过程</p>
<figure data-type="image" tabindex="4"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319152657088.png" alt="image-20200319152657088" loading="lazy"></figure>
<blockquote>
<p>举个例子,A给B打电话,B接了之后</p>
<p>A问:喂,你能听到吗?</p>
<p>B回答:能,你那能听到吗?</p>
<p>A回到:嗯,我这可以听到</p>
<p>然后在说具体的事情,这个其实就是三次握手的过程</p>
</blockquote>
<h3 id="四次挥手">四次挥手</h3>
<figure data-type="image" tabindex="5"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319153849447.png" alt="image-20200319153849447" loading="lazy"></figure>
<h2 id="用户数据报协议udp">用户数据报协议UDP</h2>
<p>传输控制协议(UDP)提供了一个服务,这个服务有以下特点</p>
<ol>
<li>无连接</li>
<li>不可靠</li>
<li>数据报尽力传输</li>
</ol>
<p>报文结构如下:</p>
<figure data-type="image" tabindex="6"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319154239775.png" alt="image-20200319154239775" loading="lazy"></figure>
<p>这个里边只有发送端端口号,接收端端口号,要发送的数据的长度,校验码,然后就是要发送的数据了</p>
<p>如果在udp上构建应用程序,关注以下几点</p>
<ol>
<li>
<p>应用进程更容易控制发送什么数据和什么时候发</p>
<blockquote>
<p>tcp建立连接需要一个过程,这个时间可长可短,数据准备好了不一定能马上发出去,udp数据准备好了就可以直接发送了</p>
</blockquote>
</li>
<li>
<p>无需建立连接</p>
</li>
<li>
<p>吴连接状态</p>
</li>
<li>
<p>首部开销小</p>
<blockquote>
<p>首部只有发送端端口号,接收端端口号,要发送的数据的长度,校验码,比tcp的小</p>
</blockquote>
</li>
</ol>
<h2 id="tcp和udp的比较">TCP和UDP的比较</h2>
<figure data-type="image" tabindex="7"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319154915219.png" alt="image-20200319154915219" loading="lazy"></figure>
<p>TCP有这么多的有点,那么我们什么时候用UDP呢?</p>
<p>使用udp是对于数据可靠性要求不高的时候或者要求实时性可以使用</p>
<p>比如视频聊天,语音聊天,直播等,我们不关心以前做了什么,我们只关心现在做了什么,要求实时性</p>
<p>同时视频偶尔丢包导致视频有点模糊我们也能接受,这种情况下丢失一些数据也没有关系</p>
<p>再比如物联网开发上的一些日志上报等,比如摩拜单车的数据定位,偶尔丢一些包也没有大问题</p>
<p>在这些场景下,我们可以使用udp协议,充分应用到udp的快速,占用资源少的一些特点</p>
<h2 id="针对第四层的传输协议如何开发">针对第四层的传输协议如何开发</h2>
<p>在了解java如何开发tcp客户端/服务端应用之前,我们还需要了解一个东西,那就是Socket编程</p>
<h3 id="socket编程">Socket编程</h3>
<h4 id="概念-2">概念</h4>
<p>Socket编程是网络中应用最广泛的网络应用编程接口,实现3种底层协议接口,哪三种?</p>
<ol>
<li>数据报类型套接字SOCK_DGRAM(面向UDP接口)</li>
<li>流式套接字SOCK_STREAM(面向tcp接口)</li>
<li>原始套接字SOCK_RAW(面向网络层协议接口IP,ICMP等)</li>
</ol>
<p>这种编程接口在操作系统的底层已经帮我们实现了,不管什么语言的应用程序,只要在操作系统上去操作网络,用的都是这样统一的Socket编程接口, 不管是什么语言去建立网络连接,都需要经过这么一个流程:</p>
<figure data-type="image" tabindex="8"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319160202256.png" alt="image-20200319160202256" loading="lazy"></figure>
<p>创建套接字,就是socket,然后绑定端口,不管是客户端还是服务端都会有端口绑定的过程,然后是发送数据,然后接受数据,最后端口连接</p>
<h4 id="socket-api函数定义">Socket  API函数定义</h4>
<ol>
<li>listen(),accept() 只能用于服务端</li>
<li>connect()只能用户客户端</li>
<li>socket() bind() send() recv(),sendto() recvfrom(),close() 两端都可以用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程中止的几种方式]]></title>
        <id>https://sdivens.github.io/post/thread-interrupt/</id>
        <link href="https://sdivens.github.io/post/thread-interrupt/">
        </link>
        <updated>2020-03-19T06:13:18.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<p>我们已经知道了线程的<a href="https://sdivens.github.io/post/threadStatus">6种状态</a>,现在我们在说一下终止线程的几种方式</p>
<ol>
<li>stop(<strong>不建议</strong>)</li>
<li>interrupt</li>
<li>标志位</li>
</ol>
<p>我们先说stop</p>
<h1 id="stop">stop</h1>
<p>stop是终止线程的一种方法</p>
<p>调用stop会终止一个线程并且清除监视器锁的信息,但是可能<strong>导致线程安全问题</strong>,JDK不建议使用,为什么不建议使用?因为它破坏了synchronized的原子性,我们来验证一下</p>
<p>我们先定义一个线程</p>
<pre><code class="language-java">public class StopThread extends Thread {
    private int i = 0, j = 0;

    @Override
    public void run() {
        synchronized (this) {
            // 增加同步锁，确保线程安全
            ++i;
            try {
                // 休眠10秒,模拟耗时操作
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            ++j;
        }
    }

    /** * 打印i和j */
    public void print() {
        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
    }
}
</code></pre>
<p>在这个线程中,我们定义了一个同步代码块,主要是进行<code>++i</code>和<code>++j</code>操作,而且这两个操作是原子性的,要么都成功,要么都失败</p>
<p>现在我们用另一个线程来启动这个线程</p>
<pre><code class="language-java">public class ThreadStopDemo {
    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        thread.start();
        // 休眠1秒，确保i变量自增成功
        Thread.sleep(1000);
        // 暂停线程
          thread.stop(); // 错误的终止
        while (thread.isAlive()) {
            // 确保线程已经终止
        } // 输出结果
        thread.print();
    }
}
</code></pre>
<p>这个运行的过程我们可以看一下这个示例图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/image-20200319134708307.png" alt="image-20200319134708307" loading="lazy"></figure>
<p>ThreadStopDemo先启动一个StopThread线程,然后自己休眠1秒,这个时候StopThread开始执行<code>i++</code>,执行完<code>i++</code>之后,线程休眠10秒,一秒钟之后,StopThread主线程重新启动,调用<code>thread.stop()</code>停止thread线程,然后等待thread线程退出,StopThread线程收到停止线程的指令之后,清除监视器锁信息,退出线程,之后的<code>++j</code>不会得到执行.主线程通过循环判断<code>thread.isAlive()</code>知道Thread子线程退出,然后主线程退出</p>
<p>这个过程中有个什么问题呢?我们要知道synchronized可以保证线程的安全,保证这个代码块的原子性,所以这个<code>i++</code>和这个<code>j++</code>应该要保证同时执行,要么都成功,要么都失败.所以预期的结果要么<code>i=j=0</code>或者<code>i=j=</code>1,但是在上述的整个过程中,线程终止破坏了这个原子性,因为<code>++i</code>执行了,但是<code>++j</code>却没有得到执行,所以最后运行的结果是<code>i = 1 j = 0</code>,所以我们说这种方式是破坏了synchronized的原子性</p>
<p>那么我们在看第二种中断线程的方法</p>
<h1 id="interrupt">interrupt</h1>
<p>这是正确的线程中止,我们看interrupt以下的几个特点</p>
<ol>
<li>如果目标线程在调用Object类的wait(),wait(long),wait(long,int),join(),join(long,int)或sleep(long,int)方法时被阻塞,那么interrupt方法会生效,目标线程的中断状态将会被清除,同时目标以上方法抛出InterruptedException异常</li>
<li>如果目标线程是被I/O或NIO中的Channel所阻塞,同样,I/O操作会被中断并且返回一个特殊的异常值,达到中止线程的目的</li>
<li>如果以上条件都不满足,则会设置目标线程的中断状态</li>
</ol>
<p>上面那个例子,如果将<code>thread.stop()</code>改成<code>thread.interrupt()</code>,那么会捕获一个InterruptedException异常,然后会输出正确值<code>i = j = 1</code>,我们看一下改完之后的运行结果:</p>
<pre><code>java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.zdw.demo.threadTest.StopThread.run(StopThread.java:13)
i=1 j=1
</code></pre>
<p>我们在看第三种中止线程的方法</p>
<h1 id="标志位">标志位</h1>
<p>我们看代码</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}
</code></pre>
<p>我们在代码中有一个类成员变量<code>public volatile static boolean flag = true</code>,然后我们在线程中了判断这个值是否为true,如果是true,俺么继续运行我们的逻辑,如果不是true,就不会进入到while循环中,线程就会结束,从而达到了中止线程的目的,那么什么时候将这个flag设为false呢,上述例子中我们是在主线程中将flag设为false,从而可以在我们需要的时候中止目标线程的执行</p>
<blockquote>
<p>注意<code>public volatile static boolean flag = true</code>中的<code>volatile</code>关键字,他保证了线程之间共享变量的可见性,以后会说到这个关键字,如果没有这个关键字,子线程是不会停止的.可以自己尝试试一下,去掉这个关键字后的运行结果</p>
</blockquote>
<p>以上就是今天说的中止线程的几种方式</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文章目录]]></title>
        <id>https://sdivens.github.io/post/toc/</id>
        <link href="https://sdivens.github.io/post/toc/">
        </link>
        <updated>2020-03-19T03:31:00.000Z</updated>
        <summary type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
<!-- more -->
<h1 id="首页"><a href="https://sdivens.github.io/">首页</a></h1>
<h1 id="多线程并发编程">多线程并发编程</h1>
<h2 id="线程介绍"><a href="https://sdivens.github.io/post/java-thread/">线程介绍</a></h2>
<h2 id="线程的状态"><a href="https://sdivens.github.io/post/threadStatus">线程的状态</a></h2>
<h2 id="线程中止的几种方式"><a href="https://sdivens.github.io/post/thread-interrupt">线程中止的几种方式</a></h2>
<h2 id="线程通信"><a href="https://sdivens.github.io/post/thread-notice">线程通信</a></h2>
<hr>
<h1 id="高并发网络编程">高并发网络编程</h1>
<h2 id="tcpudp协议"><a href="https://sdivens.github.io/post/internet-tcpandudp">TCP&amp;UDP协议</a></h2>
<h2 id="bio阻塞模式网络编程上"><a href="https://sdivens.github.io/post/net-bio-1">BIO阻塞模式网络编程(上)</a></h2>
<h2 id="bio阻塞模式网络编程上-2"><a href="https://sdivens.github.io/post/net-bio-2">BIO阻塞模式网络编程(上)</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态]]></title>
        <id>https://sdivens.github.io/post/threadStatus/</id>
        <link href="https://sdivens.github.io/post/threadStatus/">
        </link>
        <updated>2020-03-19T03:21:56.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<h1 id="线程的状态有哪些">线程的状态有哪些</h1>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>中我们提到了线程有6个状态,是哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(可运行/就绪)</li>
<li>BLOCK(阻塞)</li>
<li>WAITING(等待)</li>
<li>TIME WAITING(等待一定的时间)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>那么今天我们来具体介绍一下这6个状态以及状态之间的关系和转换</p>
<h2 id="new">NEW</h2>
<p>首先是线程的创建,<a href="https://sdivens.github.io/post/java-thread/">之前</a>我们已经说过线程是怎么创建的,线程创建之后的状态就是NEW的状态,这个是线程的初始状态</p>
<h2 id="runnable">RUNNABLE</h2>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>我们也说过RUNNABLE是线程创建之后调用线程的start()方法,然后就会进入Runnable状态,这个状态不是线程的运行状态,而是告诉cup当前状态是可运行的,等待CPU有时间来启动这个线程执行线程方法</p>
<h2 id="block">BLOCK</h2>
<p>block是阻塞状态,这个是线程阻塞等待监视器锁的一个状态,一般是处于synchronized或方法中被阻塞</p>
<h2 id="waiting">WAITING</h2>
<p>线程的等待状态,一下是不带超时时间的线程等待方式</p>
<pre><code>1. Object.wait
2. Thread.join
3. LockSupport.park
</code></pre>
<h2 id="time-waiting">TIME WAITING</h2>
<p>这个也是线程的等待状态,但是是带超时时间的,等待一段时间后自动唤醒,有以下一些方法</p>
<ol>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUtil</li>
</ol>
<h2 id="terminated">TERMINATED</h2>
<p>线程的终结状态,线程结束后的状态(包括线程正常结束和线程出现异常退出)</p>
<hr>
<p>介绍了各个线程之后我们说一些它的转换关系,可以看下边的图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/image-20200319111241472.png" alt="image-20200319111241472" loading="lazy"></figure>
<p>在这个图中可以清晰的看到各个线程之间的转换关系</p>
<p>然后在通过代码示例来验证一下</p>
<pre><code class="language-java">public class ThreadStatusDemo {
    public static Thread thread1;
    public static ThreadStatusDemo obj;

    public static void main(String[] args) throws Exception {
        // 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
        System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread1 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
        thread1.start();
        Thread.sleep(2000L); // 等待thread1执行结束，再看状态
        System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
        // thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

        System.out.println();
        System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {// 将线程2移动到等待状态，1500后自动唤醒
                    Thread.sleep(1500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread2 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        thread2.start();
        System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(200L); // 等待200毫秒，再看状态
        System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
        System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

        System.out.println();
        System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (ThreadStatusDemo.class) {
                    System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
                    System.out.println(&quot;thread3 执行了&quot;);
                }
            }
        });
        synchronized (ThreadStatusDemo.class) {
            System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            thread3.start();
            System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            Thread.sleep(200L); // 等待200毫秒，再看状态
            System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
        }
        Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
        System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread3.getState().toString());

    }

}
</code></pre>
<p>执行结果如下:</p>
<pre><code>#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################
没调用start方法，thread1当前状态：NEW
thread1当前状态：RUNNABLE
thread1 执行了
等待两秒，再看thread1当前状态：TERMINATED

############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################
没调用start方法，thread2当前状态：NEW
调用start方法，thread2当前状态：RUNNABLE
等待200毫秒，再看thread2当前状态：TIMED_WAITING
thread2当前状态：RUNNABLE
thread2 执行了
等待3秒，再看thread2当前状态：TERMINATED

############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################
没调用start方法，thread3当前状态：NEW
调用start方法，thread3当前状态：RUNNABLE
等待200毫秒，再看thread3当前状态：BLOCKED
thread3当前状态：RUNNABLE
thread3 执行了
等待3秒，让thread3抢到锁，再看thread3当前状态：TERMINATED
</code></pre>
<p>好了,对于线程的状态都了解了吗?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 多线程之线程介绍]]></title>
        <id>https://sdivens.github.io/post/java-thread/</id>
        <link href="https://sdivens.github.io/post/java-thread/">
        </link>
        <updated>2020-03-18T08:33:08.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
<!-- more -->
<h1 id="什么是线程">什么是线程</h1>
<p><strong>线程是一种计算机资源,负责处理或执行某件事情</strong>,比如说扫地,如果是你来扫地,那么你就是扫地的线程,如果是扫地机器人来扫地,那么扫地机器人就是扫地的线程,如果你扫完了地,又去洗菜了,那么你就变成了洗菜的线程,扫地的线程就结束了,<strong>所以线程是某件事情的执行者,这种执行者也是一种资源</strong>,因为你只有一个人,不能又扫地又洗菜,只能先做一件事,在做另外一件事</p>
<h1 id="什么是多线程">什么是多线程</h1>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">上面</a>提到线程是一种资源,比如一个扫地机器人,那么多线程指的就是多个资源,比如如果你有3个扫地机器人,那么可以一个扫卧室,一个扫大厅,还有一个扫厨房,可以同时进行,加快效率</p>
<h1 id="为什么-用多线程">为什么 用多线程</h1>
<p>在解释了什么是线程与多线程之后,我们需要了解一个问题,多线程是用来干什么的?为什么要用多线程?</p>
<p><strong>多线程是用来解决效率问题</strong>,比如上边的例子,假设家里有3个房间(卧室,大厅,厨房),假设每个房间打扫需要10分钟,如果只有一个扫地机器人的话,一共需要30分钟可以把家里全部打扫完毕,但是如果有3个机器人,那么可以每个机器人负责打扫一个房间,3个房间可以同时进行打扫,那么打扫完成3个房间一个需要10分钟就够了,所以多线程可以解决效率问题</p>
<h1 id="多线程如何使用">多线程如何使用</h1>
<p>了解了为什么要使用多线程之后,在来看如何写一个多线程呢?</p>
<p>首先是创建线程,如何创建一个线程呢?创建线程有两种方法</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="继承thread类">继承Thread类</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是继承Thread类,然后重写父类的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new MyThread().start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p><code>new MyThread().start();</code>这个代码就是先new一个实例,在调用实例的start()方法就可以调用这个线程了,那么有两个问题</p>
<ol>
<li>start()方法是干什么的?为什么要调用start()方法而不是调用run()方法?</li>
<li>这个程序的运行结果是什么?</li>
</ol>
<p>我们之后在解答这两个问题,现在我们了解了如何通过继承Thread来创建和使用一个线程,那么我们再看如何通过实现Runnable接口来创建和使用线程</p>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {
    
    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是实现Runnable接口,然后实现接口中的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?和继承Thread实现的类一样吗?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p>我们可以看到是通过<code>new Thread(new MyRunnableThread()).start()</code>来启动一个线程的,这个和Thread的方式有点不同,对比一下,Thread是通过<code>new MyThread().start();</code>来启动一个线程的,而这个呢是先new MyRunnableThread这个对象,然后在new Thread,把MyRunnableThread的对象实例传入到Thread的构造函数中,在和之前一样通过start方法来启动一个线程,这里调用的start()方法和之前的那个一样,我们再来解答之前提出的两个问题</p>
<h2 id="为什么调用start方法">为什么调用start()方法</h2>
<p>要解释这个原因,要先知道线程的6个状态,哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(就绪/可运行)</li>
<li>BLOCK(阻塞)</li>
<li>WATTING(等待运行)</li>
<li>TIME WAITING(有时间限制的等待运行)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>这6种状态我们以后再讲,现在先来说说NEW(创建)和RUNNABLE(就绪/可运行)这两个状态</p>
<p>NEW(创建)是在线程创建之后初始的状态,每一个线程刚创建的时候就是这个状态,比如说<code>new MyThread()</code>和<code>new Thread(new MyRunnableThread())</code>就处在这个状态,那么什么是RUNNABLE(就绪/可运行)状态呢?</p>
<p>RUNNABLE(就绪/可运行)是一个状态,标志着这个线程是可以运行的,等待CPU来启动它,是在线程在创建完成后调用start()方法,状态会从NEW转为RUNNABLE,当然其他状态也可以转为RUNNABLE,这个我们也以后讲到其他状态的时候在讲</p>
<p>我们说start()是修改了线程的状态,让线程进入可运行状态,等待CPU启动它,而run方法是一个普通方法,由调用者自己来执行这个方法,什么意思呢?看下面↓的例子</p>
<p>如果你现在要打扫卧室和大厅两个房间,你可以自己一个人全部打扫完,如果每一个房间需要10分钟,一个需要20分钟,我们知道只要有一个扫地机器人和你有一起打扫,那么只要10分钟就打扫完了,这个我们在[上面](#为什么 用多线程)已经说过了,但是如果只是单单给你一个机器人,就像<code>new Thread(new MyRunnableThread())</code>这样创建了一个线程,但是这个机器人(线程)还是无法使用的,它现在只是有个NEW的状态,必须等到这个机器人充满电了,变成了RUNNABLE(可运行)状态,这个时候这个机器人才可以正常扫地</p>
<p>在这个例子上,我们知道,如果只是给你一个线程,是无法和你一起执行的,你要扫大厅,还是要你自己去扫,所以你必须先扫卧室在扫大厅,当然你可以反过来,看你什么时候调用,此时打扫完成2个房间需要20分钟,这个就是调用run方法的效果,但是,如果你调用的是start()方法,那就好比你拿到一个扫地机器人后,先给他充电,充满电之后,你可以和它一起打扫2个房间,此时打扫房间只需要花费10分钟,因为你们是同时打扫的,你打扫卧室,它打扫大厅,这个就是start()方法和run()方法的区别,同时也是为什么我们要调用start()方法而不是调用run()方法</p>
<p>我们可以通过以下代码来验证一下</p>
<p>我们先看第一个,如果是调用run()方法的情况</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).run();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>此时的运行结果如下:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162542899.png" alt="image-20200318162542899" loading="lazy"></figure>
<p>我们发现,打扫卧室的是main线程,打扫大厅的实际也是main线程,说明打扫打扫着两个房间是同一个线程,而且打扫每个房间需要1秒,打扫2个房间一个花了2秒</p>
<p>那么如果将run()改成start()方法呢?会需要几秒打扫2个房间呢?我们看改完之后的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>我们将run()改成start()方法之后,我们来看一下运行的结果:</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162845172.png" alt="image-20200318162845172" loading="lazy"></figure>
<p>我们可以看到第一,打扫大厅和打扫卧室的不是同一个线程,说明确实有两个线程(主人+扫地机器人)在打扫房间,另外打扫完成一个花了1秒钟,说明这两个房间确实是同时在打扫的</p>
<p>那么现在,你确实知道为什么要调用start()而不用run()方法了吗?</p>
<p>还有上面的第二个问题,这个*程序的运行结果是什么?*这个问题就是上面的运行结果,你了解了吗?</p>
]]></content>
    </entry>
</feed>