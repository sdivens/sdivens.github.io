<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sdivens.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-18T09:12:00.548Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sdivens.github.io"/>
    <link rel="self" href="https://sdivens.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://sdivens.github.io/images/avatar.png</logo>
    <icon>https://sdivens.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[java 多线程之线程介绍]]></title>
        <id>https://sdivens.github.io/post/java-thread/</id>
        <link href="https://sdivens.github.io/post/java-thread/">
        </link>
        <updated>2020-03-18T08:33:08.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
<!-- more -->
<h1 id="什么是线程">什么是线程</h1>
<p><strong>线程是一种计算机资源,负责处理或执行某件事情</strong>,比如说扫地,如果是你来扫地,那么你就是扫地的线程,如果是扫地机器人来扫地,那么扫地机器人就是扫地的线程,如果你扫完了地,又去洗菜了,那么你就变成了洗菜的线程,扫地的线程就结束了,<strong>所以线程是某件事情的执行者,这种执行者也是一种资源</strong>,因为你只有一个人,不能又扫地又洗菜,只能先做一件事,在做另外一件事</p>
<h1 id="什么是多线程">什么是多线程</h1>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">上面</a>提到线程是一种资源,比如一个扫地机器人,那么多线程指的就是多个资源,比如如果你有3个扫地机器人,那么可以一个扫卧室,一个扫大厅,还有一个扫厨房,可以同时进行,加快效率</p>
<h1 id="为什么-用多线程">为什么 用多线程</h1>
<p>在解释了什么是线程与多线程之后,我们需要了解一个问题,多线程是用来干什么的?为什么要用多线程?</p>
<p><strong>多线程是用来解决效率问题</strong>,比如上边的例子,假设家里有3个房间(卧室,大厅,厨房),假设每个房间打扫需要10分钟,如果只有一个扫地机器人的话,一共需要30分钟可以把家里全部打扫完毕,但是如果有3个机器人,那么可以每个机器人负责打扫一个房间,3个房间可以同时进行打扫,那么打扫完成3个房间一个需要10分钟就够了,所以多线程可以解决效率问题</p>
<h1 id="多线程如何使用">多线程如何使用</h1>
<p>了解了为什么要使用多线程之后,在来看如何写一个多线程呢?</p>
<p>首先是创建线程,如何创建一个线程呢?创建线程有两种方法</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="继承thread类">继承Thread类</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是继承Thread类,然后重写父类的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new MyThread().start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p><code>new MyThread().start();</code>这个代码就是先new一个实例,在调用实例的start()方法就可以调用这个线程了,那么有两个问题</p>
<ol>
<li>start()方法是干什么的?为什么要调用start()方法而不是调用run()方法?</li>
<li>这个程序的运行结果是什么?</li>
</ol>
<p>我们之后在解答这两个问题,现在我们了解了如何通过继承Thread来创建和使用一个线程,那么我们再看如何通过实现Runnable接口来创建和使用线程</p>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {
    
    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是实现Runnable接口,然后实现接口中的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?和继承Thread实现的类一样吗?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p>我们可以看到是通过<code>new Thread(new MyRunnableThread()).start()</code>来启动一个线程的,这个和Thread的方式有点不同,对比一下,Thread是通过<code>new MyThread().start();</code>来启动一个线程的,而这个呢是先new MyRunnableThread这个对象,然后在new Thread,把MyRunnableThread的对象实例传入到Thread的构造函数中,在和之前一样通过start方法来启动一个线程,这里调用的start()方法和之前的那个一样,我们再来解答之前提出的两个问题</p>
<h2 id="为什么调用start方法">为什么调用start()方法</h2>
<p>要解释这个原因,要先知道线程的6个状态,哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(就绪/可运行)</li>
<li>BLOCK(阻塞)</li>
<li>WATTING(等待运行)</li>
<li>TIME WAITING(有时间限制的等待运行)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>这6种状态我们以后再讲,现在先来说说NEW(创建)和RUNNABLE(就绪/可运行)这两个状态</p>
<p>NEW(创建)是在线程创建之后初始的状态,每一个线程刚创建的时候就是这个状态,比如说<code>new MyThread()</code>和<code>new Thread(new MyRunnableThread())</code>就处在这个状态,那么什么是RUNNABLE(就绪/可运行)状态呢?</p>
<p>RUNNABLE(就绪/可运行)是一个状态,标志着这个线程是可以运行的,等待CPU来启动它,是在线程在创建完成后调用start()方法,状态会从NEW转为RUNNABLE,当然其他状态也可以转为RUNNABLE,这个我们也以后讲到其他状态的时候在讲</p>
<p>我们说start()是修改了线程的状态,让线程进入可运行状态,等待CPU启动它,而run方法是一个普通方法,由调用者自己来执行这个方法,什么意思呢?看下面↓的例子</p>
<p>如果你现在要打扫卧室和大厅两个房间,你可以自己一个人全部打扫完,如果每一个房间需要10分钟,一个需要20分钟,我们知道只要有一个扫地机器人和你有一起打扫,那么只要10分钟就打扫完了,这个我们在[上面](#为什么 用多线程)已经说过了,但是如果只是单单给你一个机器人,就像<code>new Thread(new MyRunnableThread())</code>这样创建了一个线程,但是这个机器人(线程)还是无法使用的,它现在只是有个NEW的状态,必须等到这个机器人充满电了,变成了RUNNABLE(可运行)状态,这个时候这个机器人才可以正常扫地</p>
<p>在这个例子上,我们知道,如果只是给你一个线程,是无法和你一起执行的,你要扫大厅,还是要你自己去扫,所以你必须先扫卧室在扫大厅,当然你可以反过来,看你什么时候调用,此时打扫完成2个房间需要20分钟,这个就是调用run方法的效果,但是,如果你调用的是start()方法,那就好比你拿到一个扫地机器人后,先给他充电,充满电之后,你可以和它一起打扫2个房间,此时打扫房间只需要花费10分钟,因为你们是同时打扫的,你打扫卧室,它打扫大厅,这个就是start()方法和run()方法的区别,同时也是为什么我们要调用start()方法而不是调用run()方法</p>
<p>我们可以通过以下代码来验证一下</p>
<p>我们先看第一个,如果是调用run()方法的情况</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).run();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>此时的运行结果如下:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162542899.png" alt="image-20200318162542899" loading="lazy"></figure>
<p>我们发现,打扫卧室的是main线程,打扫大厅的实际也是main线程,说明打扫打扫着两个房间是同一个线程,而且打扫每个房间需要1秒,打扫2个房间一个花了2秒</p>
<p>那么如果将run()改成start()方法呢?会需要几秒打扫2个房间呢?我们看改完之后的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>我们将run()改成start()方法之后,我们来看一下运行的结果:</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162845172.png" alt="image-20200318162845172" loading="lazy"></figure>
<p>我们可以看到第一,打扫大厅和打扫卧室的不是同一个线程,说明确实有两个线程(主人+扫地机器人)在打扫房间,另外打扫完成一个花了1秒钟,说明这两个房间确实是同时在打扫的</p>
<p>那么现在,你确实知道为什么要调用start()而不用run()方法了吗?</p>
<p>还有上面的第二个问题,这个*程序的运行结果是什么?*这个问题就是上面的运行结果,你了解了吗?</p>
]]></content>
    </entry>
</feed>