<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sdivens.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-19T09:11:07.707Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sdivens.github.io"/>
    <link rel="self" href="https://sdivens.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://sdivens.github.io/images/avatar.png</logo>
    <icon>https://sdivens.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[TCP&UDP协议]]></title>
        <id>https://sdivens.github.io/post/internet-tcpandudp/</id>
        <link href="https://sdivens.github.io/post/internet-tcpandudp/">
        </link>
        <updated>2020-03-19T09:01:54.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java网络知识的世界</p>
<p>让我们一起学习,研究java高并发网络编程的知识吧</p>
<!-- more -->
<h1 id="osi网络七层模型">OSI网络七层模型</h1>
<h2 id="概念">概念</h2>
<p>为了让不同计算机厂家的计算机能够互相通信,以便在更大范围内进行通信,有必要建立一个国际范围的网络体系结构标准</p>
<p>网络七层模型是哪七层呢?从上到下分别是:</p>
<ol>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ol>
<p>我们看以下示例图:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319142811887.png" alt="image-20200319142811887" loading="lazy"></figure>
<p>这个是OSI网络七层模型</p>
<h2 id="为什么要弄这七层模型呢">为什么要弄这七层模型呢</h2>
<p>其中一个原因是可以每个层单独处理,比如做网线的,就只要处理物理层的内容,而不用关心整个的网络结构</p>
<h2 id="各个层次的主要功能">各个层次的主要功能</h2>
<p>首先是低三层,哪三层是低三层呢?</p>
<h3 id="低三层">低三层</h3>
<ol>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
</ol>
<p>物理层主要是使原始的数据比特流能够在物理介质上传输</p>
<blockquote>
<p>这句话的意思是怎么样才可以让电流,光等这些电信号,光信号能够在光纤的两端进行通信</p>
</blockquote>
<p>数据链路层主要是通过校验,确认,反馈,重发等手段,形成稳定的数据链路</p>
<blockquote>
<p>这句话的意思是,通过物理层发送的信号可能会有丢失等各种情况,数据链路层为了防止丢失数据还不知道,所以有数据校验,确认,反馈等,发送方如果确认数据丢失,需要重发等</p>
</blockquote>
<p>所以物理层和数据链路层主要是解决了两个端点之间(比如说一根网线的两端)的通信问题,那么我们说网络是有很多节点的</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319144438330.png" alt="image-20200319144438330" loading="lazy"></figure>
<p>那么像网络这么复杂的节点,A需要发送一个数据,那么怎么知道发送到哪个机器上去呢?这个就是网络层要解决的事情</p>
<p>网络层提供了一个互联网之间数据链路上的<strong>逻辑链接</strong>,比如说IP协议,通过ip可以定位到正确的数据目的地,比如我们要发送一个数据,这个数据要发给谁?我们需要通过ip定位到这个目的的地址,从而通过网络层的技术,将一个节点的数据发送到另外一个节点</p>
<blockquote>
<p>如果我们要邮寄一封信件,我们需要在信上填写准确的收信地址(ip地址),然后给到邮局(服务器),通过邮局派发的送信员送到目的地,其中发送方是发件人,接收方是收件人,信息是信件,链路是公路或者乡村小路</p>
</blockquote>
<p>以上就是低三层,低三层的目的是为了<strong>屏蔽底层网络的复杂性</strong>,我们作为java开发等后端开发人员,是不需要太过于关注低三层</p>
<h3 id="中间层">中间层</h3>
<p>传输层是中间层,承上启下,主要提供了<strong>可靠的</strong> <strong>端口到端口的</strong>数据传输服务(TCP/UDP协议)</p>
<p>我们说之前ip地址提供了网络之间访问到某个机器的地址,但是他没法提供具体的端口,TCP/TDP协议就是对具体传输层的定义,我们的网络应用大多是基于传输层开发的,所以了解传输层(TCP/UDP)对于我们开发网络应用是很有帮助的</p>
<h3 id="高三层">高三层</h3>
<ol>
<li>会话层 负责建立,管理和终止进程之间的会话和数据交换</li>
<li>表示层 负责数据格式转换,数据加密解密,压缩与解压缩等</li>
<li>应用层 为用户的应用进程提供网络服务</li>
</ol>
<p>可以将这三层看成是一个应用层,比如HTPP服务器,他实现了高三层的功能</p>
<p>比如说会话层是关闭连接和建立连接的过程,表示层是https或者md5等相关的处理,http本身也是一种协议,是基于tcp开发的针对于web服务的协议</p>
<p>我们主要了解传输层与应用层</p>
<h2 id="传输控制协议tcp">传输控制协议TCP</h2>
<p>传输控制协议(TCP)提供了一个服务,这个服务有以下特点</p>
<ol>
<li>面向连接</li>
<li>可靠</li>
<li>有序</li>
<li>字节流传输</li>
</ol>
<p>应用程序在使用TCP之前,必须先建立TCP连接,建立连接需要要一个tcp报文,报文结构如下:</p>
<figure data-type="image" tabindex="3"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319152117553.png" alt="image-20200319152117553" loading="lazy"></figure>
<p>对于tcp连接需要有几个特点需要了解</p>
<h3 id="三次握手">三次握手</h3>
<p>三次握手的过程</p>
<figure data-type="image" tabindex="4"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319152657088.png" alt="image-20200319152657088" loading="lazy"></figure>
<blockquote>
<p>举个例子,A给B打电话,B接了之后</p>
<p>A问:喂,你能听到吗?</p>
<p>B回答:能,你那能听到吗?</p>
<p>A回到:嗯,我这可以听到</p>
<p>然后在说具体的事情,这个其实就是三次握手的过程</p>
</blockquote>
<h3 id="四次挥手">四次挥手</h3>
<figure data-type="image" tabindex="5"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319153849447.png" alt="image-20200319153849447" loading="lazy"></figure>
<h2 id="用户数据报协议udp">用户数据报协议UDP</h2>
<p>传输控制协议(UDP)提供了一个服务,这个服务有以下特点</p>
<ol>
<li>无连接</li>
<li>不可靠</li>
<li>数据报尽力传输</li>
</ol>
<p>报文结构如下:</p>
<figure data-type="image" tabindex="6"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319154239775.png" alt="image-20200319154239775" loading="lazy"></figure>
<p>这个里边只有发送端端口号,接收端端口号,要发送的数据的长度,校验码,然后就是要发送的数据了</p>
<p>如果在udp上构建应用程序,关注以下几点</p>
<ol>
<li>
<p>应用进程更容易控制发送什么数据和什么时候发</p>
<blockquote>
<p>tcp建立连接需要一个过程,这个时间可长可短,数据准备好了不一定能马上发出去,udp数据准备好了就可以直接发送了</p>
</blockquote>
</li>
<li>
<p>无需建立连接</p>
</li>
<li>
<p>吴连接状态</p>
</li>
<li>
<p>首部开销小</p>
<blockquote>
<p>首部只有发送端端口号,接收端端口号,要发送的数据的长度,校验码,比tcp的小</p>
</blockquote>
</li>
</ol>
<h2 id="tcp和udp的比较">TCP和UDP的比较</h2>
<figure data-type="image" tabindex="7"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319154915219.png" alt="image-20200319154915219" loading="lazy"></figure>
<p>TCP有这么多的有点,那么我们什么时候用UDP呢?</p>
<p>使用udp是对于数据可靠性要求不高的时候或者要求实时性可以使用</p>
<p>比如视频聊天,语音聊天,直播等,我们不关心以前做了什么,我们只关心现在做了什么,要求实时性</p>
<p>同时视频偶尔丢包导致视频有点模糊我们也能接受,这种情况下丢失一些数据也没有关系</p>
<p>再比如物联网开发上的一些日志上报等,比如摩拜单车的数据定位,偶尔丢一些包也没有大问题</p>
<p>在这些场景下,我们可以使用udp协议,充分应用到udp的快速,占用资源少的一些特点</p>
<h2 id="针对第四层的传输协议如何开发">针对第四层的传输协议如何开发</h2>
<p>在了解java如何开发tcp客户端/服务端应用之前,我们还需要了解一个东西,那就是Socket编程</p>
<h3 id="socket编程">Socket编程</h3>
<h4 id="概念-2">概念</h4>
<p>Socket编程是网络中应用最广泛的网络应用编程接口,实现3种底层协议接口,哪三种?</p>
<ol>
<li>数据报类型套接字SOCK_DGRAM(面向UDP接口)</li>
<li>流式套接字SOCK_STREAM(面向tcp接口)</li>
<li>原始套接字SOCK_RAW(面向网络层协议接口IP,ICMP等)</li>
</ol>
<p>这种编程接口在操作系统的底层已经帮我们实现了,不管什么语言的应用程序,只要在操作系统上去操作网络,用的都是这样统一的Socket编程接口, 不管是什么语言去建立网络连接,都需要经过这么一个流程:</p>
<figure data-type="image" tabindex="8"><img src="https://sdivens.github.io/post-images/TCPUDP%E5%8D%8F%E8%AE%AE/image-20200319160202256.png" alt="image-20200319160202256" loading="lazy"></figure>
<p>创建套接字,就是socket,然后绑定端口,不管是客户端还是服务端都会有端口绑定的过程,然后是发送数据,然后接受数据,最后端口连接</p>
<h4 id="socket-api函数定义">Socket  API函数定义</h4>
<ol>
<li>listen(),accept() 只能用于服务端</li>
<li>connect()只能用户客户端</li>
<li>socket() bind() send() recv(),sendto() recvfrom(),close() 两端都可以用</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程中止的几种方式]]></title>
        <id>https://sdivens.github.io/post/thread-interrupt/</id>
        <link href="https://sdivens.github.io/post/thread-interrupt/">
        </link>
        <updated>2020-03-19T06:13:18.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界</p>
<p>让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<p>我们已经知道了线程的<a href="https://sdivens.github.io/post/threadStatus">6种状态</a>,现在我们在说一下终止线程的几种方式</p>
<ol>
<li>stop(<strong>不建议</strong>)</li>
<li>interrupt</li>
<li>标志位</li>
</ol>
<p>我们先说stop</p>
<h1 id="stop">stop</h1>
<p>stop是终止线程的一种方法</p>
<p>调用stop会终止一个线程并且清除监视器锁的信息,但是可能<strong>导致线程安全问题</strong>,JDK不建议使用,为什么不建议使用?因为它破坏了synchronized的原子性,我们来验证一下</p>
<p>我们先定义一个线程</p>
<pre><code class="language-java">public class StopThread extends Thread {
    private int i = 0, j = 0;

    @Override
    public void run() {
        synchronized (this) {
            // 增加同步锁，确保线程安全
            ++i;
            try {
                // 休眠10秒,模拟耗时操作
                Thread.sleep(10000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            ++j;
        }
    }

    /** * 打印i和j */
    public void print() {
        System.out.println(&quot;i=&quot; + i + &quot; j=&quot; + j);
    }
}
</code></pre>
<p>在这个线程中,我们定义了一个同步代码块,主要是进行<code>++i</code>和<code>++j</code>操作,而且这两个操作是原子性的,要么都成功,要么都失败</p>
<p>现在我们用另一个线程来启动这个线程</p>
<pre><code class="language-java">public class ThreadStopDemo {
    public static void main(String[] args) throws InterruptedException {
        StopThread thread = new StopThread();
        thread.start();
        // 休眠1秒，确保i变量自增成功
        Thread.sleep(1000);
        // 暂停线程
          thread.stop(); // 错误的终止
        while (thread.isAlive()) {
            // 确保线程已经终止
        } // 输出结果
        thread.print();
    }
}
</code></pre>
<p>这个运行的过程我们可以看一下这个示例图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B/image-20200319134708307.png" alt="image-20200319134708307" loading="lazy"></figure>
<p>ThreadStopDemo先启动一个StopThread线程,然后自己休眠1秒,这个时候StopThread开始执行<code>i++</code>,执行完<code>i++</code>之后,线程休眠10秒,一秒钟之后,StopThread主线程重新启动,调用<code>thread.stop()</code>停止thread线程,然后等待thread线程退出,StopThread线程收到停止线程的指令之后,清除监视器锁信息,退出线程,之后的<code>++j</code>不会得到执行.主线程通过循环判断<code>thread.isAlive()</code>知道Thread子线程退出,然后主线程退出</p>
<p>这个过程中有个什么问题呢?我们要知道synchronized可以保证线程的安全,保证这个代码块的原子性,所以这个<code>i++</code>和这个<code>j++</code>应该要保证同时执行,要么都成功,要么都失败.所以预期的结果要么<code>i=j=0</code>或者<code>i=j=</code>1,但是在上述的整个过程中,线程终止破坏了这个原子性,因为<code>++i</code>执行了,但是<code>++j</code>却没有得到执行,所以最后运行的结果是<code>i = 1 j = 0</code>,所以我们说这种方式是破坏了synchronized的原子性</p>
<p>那么我们在看第二种中断线程的方法</p>
<h1 id="interrupt">interrupt</h1>
<p>这是正确的线程中止,我们看interrupt以下的几个特点</p>
<ol>
<li>如果目标线程在调用Object类的wait(),wait(long),wait(long,int),join(),join(long,int)或sleep(long,int)方法时被阻塞,那么interrupt方法会生效,目标线程的中断状态将会被清除,同时目标以上方法抛出InterruptedException异常</li>
<li>如果目标线程是被I/O或NIO中的Channel所阻塞,同样,I/O操作会被中断并且返回一个特殊的异常值,达到中止线程的目的</li>
<li>如果以上条件都不满足,则会设置目标线程的中断状态</li>
</ol>
<p>上面那个例子,如果将<code>thread.stop()</code>改成<code>thread.interrupt()</code>,那么会捕获一个InterruptedException异常,然后会输出正确值<code>i = j = 1</code>,我们看一下改完之后的运行结果:</p>
<pre><code>java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.zdw.demo.threadTest.StopThread.run(StopThread.java:13)
i=1 j=1
</code></pre>
<p>我们在看第三种中止线程的方法</p>
<h1 id="标志位">标志位</h1>
<p>我们看代码</p>
<pre><code class="language-java">/** 通过状态位来判断 */
public class Demo4 extends Thread {
  public volatile static boolean flag = true;

  public static void main(String[] args) throws InterruptedException {
    new Thread(() -&gt; {
      try {
        while (flag) { // 判断是否运行
          System.out.println(&quot;运行中&quot;);
          Thread.sleep(1000L);
        }
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }).start();
    // 3秒之后，将状态标志改为False，代表不继续运行
    Thread.sleep(3000L);
    flag = false;
    System.out.println(&quot;程序运行结束&quot;);
  }
}
</code></pre>
<p>我们在代码中有一个类成员变量<code>public volatile static boolean flag = true</code>,然后我们在线程中了判断这个值是否为true,如果是true,俺么继续运行我们的逻辑,如果不是true,就不会进入到while循环中,线程就会结束,从而达到了中止线程的目的,那么什么时候将这个flag设为false呢,上述例子中我们是在主线程中将flag设为false,从而可以在我们需要的时候中止目标线程的执行</p>
<blockquote>
<p>注意<code>public volatile static boolean flag = true</code>中的<code>volatile</code>关键字,他保证了线程之间共享变量的可见性,以后会说到这个关键字,如果没有这个关键字,子线程是不会停止的.可以自己尝试试一下,去掉这个关键字后的运行结果</p>
</blockquote>
<p>以上就是今天说的中止线程的几种方式</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文章目录]]></title>
        <id>https://sdivens.github.io/post/toc/</id>
        <link href="https://sdivens.github.io/post/toc/">
        </link>
        <updated>2020-03-19T03:31:00.000Z</updated>
        <summary type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于文章的顺序是按发布时间倒序的,所以为了方便顺序阅读,也为了方便查找文章,所以写了一个目录放在这<br>
学习使人进步,生命不息,学习不止!让我们一同进步</p>
<!-- more -->
<h1 id="首页"><a href="https://sdivens.github.io/">首页</a></h1>
<h1 id="多线程并发编程">多线程并发编程</h1>
<h2 id="线程介绍"><a href="https://sdivens.github.io/post/java-thread/">线程介绍</a></h2>
<h2 id="线程的状态"><a href="https://sdivens.github.io/post/threadStatus">线程的状态</a></h2>
<h2 id="线程中止的几种方式"><a href="https://sdivens.github.io/post/thread-interrupt">线程中止的几种方式</a></h2>
<hr>
<h1 id="高并发网络编程">高并发网络编程</h1>
<h2 id="tcpudp协议"><a href="https://sdivens.github.io/post/internet-tcpandudp">TCP&amp;UDP协议</a></h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程的状态]]></title>
        <id>https://sdivens.github.io/post/threadStatus/</id>
        <link href="https://sdivens.github.io/post/threadStatus/">
        </link>
        <updated>2020-03-19T03:21:56.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到java多线程的世界<br>
让我们一起学习,研究java多线程和高并发知识吧</p>
<!-- more -->
<h1 id="线程的状态有哪些">线程的状态有哪些</h1>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>中我们提到了线程有6个状态,是哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(可运行/就绪)</li>
<li>BLOCK(阻塞)</li>
<li>WAITING(等待)</li>
<li>TIME WAITING(等待一定的时间)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>那么今天我们来具体介绍一下这6个状态以及状态之间的关系和转换</p>
<h2 id="new">NEW</h2>
<p>首先是线程的创建,<a href="https://sdivens.github.io/post/java-thread/">之前</a>我们已经说过线程是怎么创建的,线程创建之后的状态就是NEW的状态,这个是线程的初始状态</p>
<h2 id="runnable">RUNNABLE</h2>
<p><a href="https://sdivens.github.io/post/java-thread/">之前</a>我们也说过RUNNABLE是线程创建之后调用线程的start()方法,然后就会进入Runnable状态,这个状态不是线程的运行状态,而是告诉cup当前状态是可运行的,等待CPU有时间来启动这个线程执行线程方法</p>
<h2 id="block">BLOCK</h2>
<p>block是阻塞状态,这个是线程阻塞等待监视器锁的一个状态,一般是处于synchronized或方法中被阻塞</p>
<h2 id="waiting">WAITING</h2>
<p>线程的等待状态,一下是不带超时时间的线程等待方式</p>
<pre><code>1. Object.wait
2. Thread.join
3. LockSupport.park
</code></pre>
<h2 id="time-waiting">TIME WAITING</h2>
<p>这个也是线程的等待状态,但是是带超时时间的,等待一段时间后自动唤醒,有以下一些方法</p>
<ol>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUtil</li>
</ol>
<h2 id="terminated">TERMINATED</h2>
<p>线程的终结状态,线程结束后的状态(包括线程正常结束和线程出现异常退出)</p>
<hr>
<p>介绍了各个线程之后我们说一些它的转换关系,可以看下边的图</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/image-20200319111241472.png" alt="image-20200319111241472" loading="lazy"></figure>
<p>在这个图中可以清晰的看到各个线程之间的转换关系</p>
<p>然后在通过代码示例来验证一下</p>
<pre><code class="language-java">public class ThreadStatusDemo {
    public static Thread thread1;
    public static ThreadStatusDemo obj;

    public static void main(String[] args) throws Exception {
        // 第一种状态切换 - 新建 -&gt; 运行 -&gt; 终止
        System.out.println(&quot;#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################&quot;);
        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;thread1当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread1 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread1当前状态：&quot; + thread1.getState().toString());
        thread1.start();
        Thread.sleep(2000L); // 等待thread1执行结束，再看状态
        System.out.println(&quot;等待两秒，再看thread1当前状态：&quot; + thread1.getState().toString());
        // thread1.start(); TODO 注意，线程终止之后，再进行调用，会抛出IllegalThreadStateException异常

        System.out.println();
        System.out.println(&quot;############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################&quot;);
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {// 将线程2移动到等待状态，1500后自动唤醒
                    Thread.sleep(1500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&quot;thread2当前状态：&quot; + Thread.currentThread().getState().toString());
                System.out.println(&quot;thread2 执行了&quot;);
            }
        });
        System.out.println(&quot;没调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        thread2.start();
        System.out.println(&quot;调用start方法，thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(200L); // 等待200毫秒，再看状态
        System.out.println(&quot;等待200毫秒，再看thread2当前状态：&quot; + thread2.getState().toString());
        Thread.sleep(3000L); // 再等待3秒，让thread2执行完毕，再看状态
        System.out.println(&quot;等待3秒，再看thread2当前状态：&quot; + thread2.getState().toString());

        System.out.println();
        System.out.println(&quot;############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################&quot;);
        Thread thread3 = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (ThreadStatusDemo.class) {
                    System.out.println(&quot;thread3当前状态：&quot; + Thread.currentThread().getState().toString());
                    System.out.println(&quot;thread3 执行了&quot;);
                }
            }
        });
        synchronized (ThreadStatusDemo.class) {
            System.out.println(&quot;没调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            thread3.start();
            System.out.println(&quot;调用start方法，thread3当前状态：&quot; + thread3.getState().toString());
            Thread.sleep(200L); // 等待200毫秒，再看状态
            System.out.println(&quot;等待200毫秒，再看thread3当前状态：&quot; + thread3.getState().toString());
        }
        Thread.sleep(3000L); // 再等待3秒，让thread3执行完毕，再看状态
        System.out.println(&quot;等待3秒，让thread3抢到锁，再看thread3当前状态：&quot; + thread3.getState().toString());

    }

}
</code></pre>
<p>执行结果如下:</p>
<pre><code>#######第一种状态切换  - 新建 -&gt; 运行 -&gt; 终止################################
没调用start方法，thread1当前状态：NEW
thread1当前状态：RUNNABLE
thread1 执行了
等待两秒，再看thread1当前状态：TERMINATED

############第二种：新建 -&gt; 运行 -&gt; 等待 -&gt; 运行 -&gt; 终止(sleep方式)###########################
没调用start方法，thread2当前状态：NEW
调用start方法，thread2当前状态：RUNNABLE
等待200毫秒，再看thread2当前状态：TIMED_WAITING
thread2当前状态：RUNNABLE
thread2 执行了
等待3秒，再看thread2当前状态：TERMINATED

############第三种：新建 -&gt; 运行 -&gt; 阻塞 -&gt; 运行 -&gt; 终止###########################
没调用start方法，thread3当前状态：NEW
调用start方法，thread3当前状态：RUNNABLE
等待200毫秒，再看thread3当前状态：BLOCKED
thread3当前状态：RUNNABLE
thread3 执行了
等待3秒，让thread3抢到锁，再看thread3当前状态：TERMINATED
</code></pre>
<p>好了,对于线程的状态都了解了吗?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java 多线程之线程介绍]]></title>
        <id>https://sdivens.github.io/post/java-thread/</id>
        <link href="https://sdivens.github.io/post/java-thread/">
        </link>
        <updated>2020-03-18T08:33:08.000Z</updated>
        <summary type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
]]></summary>
        <content type="html"><![CDATA[<p>欢迎来到<strong>java多线程</strong>的世界<br>
让我们一起学习,研究<strong>java多线程和高并发</strong>知识吧</p>
<!-- more -->
<h1 id="什么是线程">什么是线程</h1>
<p><strong>线程是一种计算机资源,负责处理或执行某件事情</strong>,比如说扫地,如果是你来扫地,那么你就是扫地的线程,如果是扫地机器人来扫地,那么扫地机器人就是扫地的线程,如果你扫完了地,又去洗菜了,那么你就变成了洗菜的线程,扫地的线程就结束了,<strong>所以线程是某件事情的执行者,这种执行者也是一种资源</strong>,因为你只有一个人,不能又扫地又洗菜,只能先做一件事,在做另外一件事</p>
<h1 id="什么是多线程">什么是多线程</h1>
<p><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B">上面</a>提到线程是一种资源,比如一个扫地机器人,那么多线程指的就是多个资源,比如如果你有3个扫地机器人,那么可以一个扫卧室,一个扫大厅,还有一个扫厨房,可以同时进行,加快效率</p>
<h1 id="为什么-用多线程">为什么 用多线程</h1>
<p>在解释了什么是线程与多线程之后,我们需要了解一个问题,多线程是用来干什么的?为什么要用多线程?</p>
<p><strong>多线程是用来解决效率问题</strong>,比如上边的例子,假设家里有3个房间(卧室,大厅,厨房),假设每个房间打扫需要10分钟,如果只有一个扫地机器人的话,一共需要30分钟可以把家里全部打扫完毕,但是如果有3个机器人,那么可以每个机器人负责打扫一个房间,3个房间可以同时进行打扫,那么打扫完成3个房间一个需要10分钟就够了,所以多线程可以解决效率问题</p>
<h1 id="多线程如何使用">多线程如何使用</h1>
<p>了解了为什么要使用多线程之后,在来看如何写一个多线程呢?</p>
<p>首先是创建线程,如何创建一个线程呢?创建线程有两种方法</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<h2 id="继承thread类">继承Thread类</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是继承Thread类,然后重写父类的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyThread extends Thread {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new MyThread().start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p><code>new MyThread().start();</code>这个代码就是先new一个实例,在调用实例的start()方法就可以调用这个线程了,那么有两个问题</p>
<ol>
<li>start()方法是干什么的?为什么要调用start()方法而不是调用run()方法?</li>
<li>这个程序的运行结果是什么?</li>
</ol>
<p>我们之后在解答这两个问题,现在我们了解了如何通过继承Thread来创建和使用一个线程,那么我们再看如何通过实现Runnable接口来创建和使用线程</p>
<h2 id="实现runnable接口">实现Runnable接口</h2>
<p>我们来看代码实现一下</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {
    
    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }
}
</code></pre>
<p>首先是实现Runnable接口,然后实现接口中的run方法,这样就可以实现了一个线程,那么这个线程要如何使用呢?和继承Thread实现的类一样吗?我么在看接下来的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        System.out.println(&quot;我是主人,我开始打扫卧室&quot;);
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);

    }
}
</code></pre>
<p>我们可以看到是通过<code>new Thread(new MyRunnableThread()).start()</code>来启动一个线程的,这个和Thread的方式有点不同,对比一下,Thread是通过<code>new MyThread().start();</code>来启动一个线程的,而这个呢是先new MyRunnableThread这个对象,然后在new Thread,把MyRunnableThread的对象实例传入到Thread的构造函数中,在和之前一样通过start方法来启动一个线程,这里调用的start()方法和之前的那个一样,我们再来解答之前提出的两个问题</p>
<h2 id="为什么调用start方法">为什么调用start()方法</h2>
<p>要解释这个原因,要先知道线程的6个状态,哪6个状态呢?</p>
<ol>
<li>NEW(创建)</li>
<li>RUNNABLE(就绪/可运行)</li>
<li>BLOCK(阻塞)</li>
<li>WATTING(等待运行)</li>
<li>TIME WAITING(有时间限制的等待运行)</li>
<li>TERMINATED(终结)</li>
</ol>
<p>这6种状态我们以后再讲,现在先来说说NEW(创建)和RUNNABLE(就绪/可运行)这两个状态</p>
<p>NEW(创建)是在线程创建之后初始的状态,每一个线程刚创建的时候就是这个状态,比如说<code>new MyThread()</code>和<code>new Thread(new MyRunnableThread())</code>就处在这个状态,那么什么是RUNNABLE(就绪/可运行)状态呢?</p>
<p>RUNNABLE(就绪/可运行)是一个状态,标志着这个线程是可以运行的,等待CPU来启动它,是在线程在创建完成后调用start()方法,状态会从NEW转为RUNNABLE,当然其他状态也可以转为RUNNABLE,这个我们也以后讲到其他状态的时候在讲</p>
<p>我们说start()是修改了线程的状态,让线程进入可运行状态,等待CPU启动它,而run方法是一个普通方法,由调用者自己来执行这个方法,什么意思呢?看下面↓的例子</p>
<p>如果你现在要打扫卧室和大厅两个房间,你可以自己一个人全部打扫完,如果每一个房间需要10分钟,一个需要20分钟,我们知道只要有一个扫地机器人和你有一起打扫,那么只要10分钟就打扫完了,这个我们在[上面](#为什么 用多线程)已经说过了,但是如果只是单单给你一个机器人,就像<code>new Thread(new MyRunnableThread())</code>这样创建了一个线程,但是这个机器人(线程)还是无法使用的,它现在只是有个NEW的状态,必须等到这个机器人充满电了,变成了RUNNABLE(可运行)状态,这个时候这个机器人才可以正常扫地</p>
<p>在这个例子上,我们知道,如果只是给你一个线程,是无法和你一起执行的,你要扫大厅,还是要你自己去扫,所以你必须先扫卧室在扫大厅,当然你可以反过来,看你什么时候调用,此时打扫完成2个房间需要20分钟,这个就是调用run方法的效果,但是,如果你调用的是start()方法,那就好比你拿到一个扫地机器人后,先给他充电,充满电之后,你可以和它一起打扫2个房间,此时打扫房间只需要花费10分钟,因为你们是同时打扫的,你打扫卧室,它打扫大厅,这个就是start()方法和run()方法的区别,同时也是为什么我们要调用start()方法而不是调用run()方法</p>
<p>我们可以通过以下代码来验证一下</p>
<p>我们先看第一个,如果是调用run()方法的情况</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).run();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>此时的运行结果如下:</p>
<figure data-type="image" tabindex="1"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162542899.png" alt="image-20200318162542899" loading="lazy"></figure>
<p>我们发现,打扫卧室的是main线程,打扫大厅的实际也是main线程,说明打扫打扫着两个房间是同一个线程,而且打扫每个房间需要1秒,打扫2个房间一个花了2秒</p>
<p>那么如果将run()改成start()方法呢?会需要几秒打扫2个房间呢?我们看改完之后的代码</p>
<pre><code class="language-java">public class MyRunnableThread implements Runnable {

    @Override
    public void run() {
        System.out.println(&quot;我是机器人,我的名字叫:&quot;+Thread.currentThread().getName()+&quot;,我开始打扫大厅&quot;);
        try {
            // 机器人需要1秒钟打扫大厅
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;大厅打扫结束&quot;);
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        System.out.println(&quot;我是主人,我的名字叫&quot; + Thread.currentThread().getName());
        System.out.println(&quot;我开始打扫卧室&quot;);
        try {
            // 人需要1秒钟打扫卧室
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new MyRunnableThread()).start();
        System.out.println(&quot;卧室打扫结束.&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;打扫两个房间一个花了&quot;+(end - start) /1000+&quot;秒&quot;);

    }
}
</code></pre>
<p>我们将run()改成start()方法之后,我们来看一下运行的结果:</p>
<figure data-type="image" tabindex="2"><img src="https://sdivens.github.io/post-images/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200318162845172.png" alt="image-20200318162845172" loading="lazy"></figure>
<p>我们可以看到第一,打扫大厅和打扫卧室的不是同一个线程,说明确实有两个线程(主人+扫地机器人)在打扫房间,另外打扫完成一个花了1秒钟,说明这两个房间确实是同时在打扫的</p>
<p>那么现在,你确实知道为什么要调用start()而不用run()方法了吗?</p>
<p>还有上面的第二个问题,这个*程序的运行结果是什么?*这个问题就是上面的运行结果,你了解了吗?</p>
]]></content>
    </entry>
</feed>